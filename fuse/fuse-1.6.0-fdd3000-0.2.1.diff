diff -Naru fuse-1.6.0/aclocal.m4 fuse-1.6.0-fdd3000-0.2.1/aclocal.m4
diff -Naru fuse-1.6.0/autom4te.cache/output.0 fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/output.0
diff -Naru fuse-1.6.0/autom4te.cache/output.1 fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/output.1
diff -Naru fuse-1.6.0/autom4te.cache/output.2 fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/output.2
diff -Naru fuse-1.6.0/autom4te.cache/output.3 fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/output.3
\ Brak znaku nowej linii na końcu pliku
diff -Naru fuse-1.6.0/autom4te.cache/requests fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/requests
diff -Naru fuse-1.6.0/autom4te.cache/traces.0 fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/traces.0
diff -Naru fuse-1.6.0/autom4te.cache/traces.1 fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/traces.1
diff -Naru fuse-1.6.0/autom4te.cache/traces.2 fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/traces.2
diff -Naru fuse-1.6.0/autom4te.cache/traces.3 fuse-1.6.0-fdd3000-0.2.1/autom4te.cache/traces.3
diff -Naru fuse-1.6.0/compile fuse-1.6.0-fdd3000-0.2.1/compile
diff -Naru fuse-1.6.0/config.guess fuse-1.6.0-fdd3000-0.2.1/config.guess
diff -Naru fuse-1.6.0/config.h.in fuse-1.6.0-fdd3000-0.2.1/config.h.in
diff -Naru fuse-1.6.0/config.h.in~ fuse-1.6.0-fdd3000-0.2.1/config.h.in~
diff -Naru fuse-1.6.0/config.sub fuse-1.6.0-fdd3000-0.2.1/config.sub
diff -Naru fuse-1.6.0/configure fuse-1.6.0-fdd3000-0.2.1/configure
diff -Naru fuse-1.6.0/configure~ fuse-1.6.0-fdd3000-0.2.1/configure~
diff -Naru fuse-1.6.0/debugger/commandl.c fuse-1.6.0-fdd3000-0.2.1/debugger/commandl.c
diff -Naru fuse-1.6.0/debugger/commandy.c fuse-1.6.0-fdd3000-0.2.1/debugger/commandy.c
diff -Naru fuse-1.6.0/debugger/commandy.h fuse-1.6.0-fdd3000-0.2.1/debugger/commandy.h
diff -Naru fuse-1.6.0/depcomp fuse-1.6.0-fdd3000-0.2.1/depcomp
diff -Naru fuse-1.6.0/fuse.c fuse-1.6.0-fdd3000-0.2.1/fuse.c
--- fuse-1.6.0/fuse.c	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/fuse.c	2023-08-07 09:56:42.511706551 +0200
@@ -70,6 +70,7 @@
 #include "peripherals/disk/beta.h"
 #include "peripherals/disk/didaktik.h"
 #include "peripherals/disk/fdd.h"
+#include "peripherals/disk/ti397.h"
 #include "peripherals/fuller.h"
 #include "peripherals/ide/divide.h"
 #include "peripherals/ide/divmmc.h"
@@ -132,6 +133,7 @@
   const char *disk_plus3;
   const char *disk_opus;
   const char *disk_plusd;
+  const char *disk_fdd3000;
   const char *disk_beta;
   const char *disk_didaktik80;
   const char *disk_disciple;
@@ -306,6 +308,7 @@
   divmmc_register_startup();
   event_register_startup();
   fdd_register_startup();
+  fdd3000_register_startup();
   fuller_register_startup();
   if1_register_startup();
   if2_register_startup();
@@ -584,6 +587,7 @@
   start_files->disk_didaktik80 = settings_current.didaktik80disk_file;
   start_files->disk_disciple = settings_current.discipledisk_file;
   start_files->disk_beta = settings_current.betadisk_file;
+  start_files->disk_fdd3000 = settings_current.fdd3000disk_file;
   start_files->dock = settings_current.dck_file;
   start_files->if2 = settings_current.if2_file;
   start_files->playback = settings_current.playback_file;
@@ -685,7 +689,11 @@
       break;
 
     case LIBSPECTRUM_CLASS_DISK_PLUS3:
-      start_files->disk_plus3 = filename; break;
+      if( periph_is_active( PERIPH_TYPE_FDD3000 ) )
+        start_files->disk_fdd3000 = filename;
+      else
+        start_files->disk_plus3 = filename;
+      break;
 
     case LIBSPECTRUM_CLASS_DISK_OPUS:
       start_files->disk_opus = filename; break;
@@ -828,6 +836,11 @@
     if( error ) return error;
   }
 
+  if( start_files->disk_fdd3000 ) {
+    error = utils_open_file( start_files->disk_fdd3000, autoload, NULL );
+    if( error ) return error;
+  }
+
   if( start_files->disk_didaktik80 ) {
     error = utils_open_file( start_files->disk_didaktik80, autoload, NULL );
     if( error ) return error;
diff -Naru fuse-1.6.0/infrastructure/startup_manager.h fuse-1.6.0-fdd3000-0.2.1/infrastructure/startup_manager.h
--- fuse-1.6.0/infrastructure/startup_manager.h	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/infrastructure/startup_manager.h	2023-08-07 09:56:42.511706551 +0200
@@ -39,6 +39,7 @@
   STARTUP_MANAGER_MODULE_DIVMMC,
   STARTUP_MANAGER_MODULE_EVENT,
   STARTUP_MANAGER_MODULE_FDD,
+  STARTUP_MANAGER_MODULE_FDD3000,
   STARTUP_MANAGER_MODULE_FULLER,
   STARTUP_MANAGER_MODULE_IF1,
   STARTUP_MANAGER_MODULE_IF2,
diff -Naru fuse-1.6.0/install-sh fuse-1.6.0-fdd3000-0.2.1/install-sh
diff -Naru fuse-1.6.0/ltmain.sh fuse-1.6.0-fdd3000-0.2.1/ltmain.sh
diff -Naru fuse-1.6.0/m4/libtool.m4 fuse-1.6.0-fdd3000-0.2.1/m4/libtool.m4
diff -Naru fuse-1.6.0/m4/lt~obsolete.m4 fuse-1.6.0-fdd3000-0.2.1/m4/lt~obsolete.m4
diff -Naru fuse-1.6.0/m4/ltoptions.m4 fuse-1.6.0-fdd3000-0.2.1/m4/ltoptions.m4
diff -Naru fuse-1.6.0/m4/ltsugar.m4 fuse-1.6.0-fdd3000-0.2.1/m4/ltsugar.m4
diff -Naru fuse-1.6.0/m4/ltversion.m4 fuse-1.6.0-fdd3000-0.2.1/m4/ltversion.m4
diff -Naru fuse-1.6.0/machines/machines_periph.c fuse-1.6.0-fdd3000-0.2.1/machines/machines_periph.c
--- fuse-1.6.0/machines/machines_periph.c	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/machines/machines_periph.c	2023-08-29 08:23:14.225672162 +0200
@@ -205,6 +205,7 @@
   periph_set_present( PERIPH_TYPE_PLUSD, PERIPH_PRESENT_OPTIONAL );
   periph_set_present( PERIPH_TYPE_SPECDRUM, PERIPH_PRESENT_OPTIONAL );
   periph_set_present( PERIPH_TYPE_USOURCE, PERIPH_PRESENT_OPTIONAL );
+  periph_set_present( PERIPH_TYPE_FDD3000, PERIPH_PRESENT_OPTIONAL );
 }
 
 /* The set of peripherals available on the 48K and similar machines */
@@ -261,6 +262,7 @@
   /* ZX Printer and Interface 2 available */
   periph_set_present( PERIPH_TYPE_INTERFACE2, PERIPH_PRESENT_OPTIONAL );
   periph_set_present( PERIPH_TYPE_ZXPRINTER_FULL_DECODE, PERIPH_PRESENT_OPTIONAL );
+  periph_set_present( PERIPH_TYPE_FDD3000, PERIPH_PRESENT_OPTIONAL );
 }
 
 /* The set of peripherals available on the Pentagon and Scorpion */
diff -Naru fuse-1.6.0/Makefile.in fuse-1.6.0-fdd3000-0.2.1/Makefile.in
diff -Naru fuse-1.6.0/memory_pages.c fuse-1.6.0-fdd3000-0.2.1/memory_pages.c
--- fuse-1.6.0/memory_pages.c	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/memory_pages.c	2023-08-07 09:56:42.518373241 +0200
@@ -42,6 +42,7 @@
 #include "memory_pages.h"
 #include "module.h"
 #include "peripherals/disk/opus.h"
+#include "peripherals/disk/ti397.h"
 #include "peripherals/spectranet.h"
 #include "peripherals/ttx2000s.h"
 #include "peripherals/ula.h"
@@ -684,6 +685,10 @@
 int
 trap_check_rom( trap_type type )
 {
+
+  if( fdd3000_available && fdd3000_active )
+    return 0;		/* FDD3000 must not be active */
+
   if( plusd_available && plusd_active )
     return 0;		/* +D must not be active */
 
diff -Naru fuse-1.6.0/menu.c fuse-1.6.0-fdd3000-0.2.1/menu.c
--- fuse-1.6.0/menu.c	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/menu.c	2023-08-07 09:56:42.521706585 +0200
@@ -35,6 +35,9 @@
 #include "peripherals/disk/didaktik.h"
 #include "peripherals/disk/disciple.h"
 #include "peripherals/disk/opus.h"
+#include "peripherals/disk/ti397.h"
+#include "peripherals/disk/fdd3000.h"
+#include "peripherals/disk/wd_fdc.h"
 #include "peripherals/disk/plusd.h"
 #include "peripherals/ide/divide.h"
 #include "peripherals/ide/divmmc.h"
@@ -294,7 +297,7 @@
   case 10: menu_select_peripheral_roms( "SpeccyBoot",      9, 1 ); return;
   case 11: menu_select_peripheral_roms( "TTX2000S",       10, 1 ); return;
   case 12: menu_select_peripheral_roms( "uSource",        11, 1 ); return;
-
+  case 13: menu_select_peripheral_roms( "FDD3000",        12, 1 ); return;
   }
 
   ui_error( UI_ERROR_ERROR,
@@ -1177,6 +1180,38 @@
 }
 
 const char*
+menu_fdd3000a_detail( void )
+{
+  fdd_t *f = fdd3000_get_fdd( FDD3000_DRIVE_A );
+
+  return menu_disk_detail( f );
+}
+
+const char*
+menu_fdd3000b_detail( void )
+{
+  fdd_t *f = fdd3000_get_fdd( FDD3000_DRIVE_B );
+
+  return menu_disk_detail( f );
+}
+
+const char*
+menu_fdd3000c_detail( void )
+{
+  fdd_t *f = fdd3000_get_fdd( FDD3000_DRIVE_C );
+
+  return menu_disk_detail( f );
+}
+
+const char*
+menu_fdd3000d_detail( void )
+{
+  fdd_t *f = fdd3000_get_fdd( FDD3000_DRIVE_D );
+
+  return menu_disk_detail( f );
+}
+
+const char*
 menu_opus1_detail( void )
 {
   fdd_t *f = opus_get_fdd( OPUS_DRIVE_1 );
@@ -1246,3 +1281,11 @@
   didaktik80_snap = 1;
   event_add( 0, z80_nmi_event );
 }
+
+
+MENU_CALLBACK( menu_machine_fdd3000reset )
+{
+  ui_widget_finish();
+  wd_fdc_master_reset( fdd3000_fdc );
+  fddReset();
+}
diff -Naru fuse-1.6.0/menu_data.dat fuse-1.6.0-fdd3000-0.2.1/menu_data.dat
--- fuse-1.6.0/menu_data.dat	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/menu_data.dat	2023-08-07 09:56:42.525039930 +0200
@@ -125,6 +125,7 @@
 Options/Select ROMs/Peripheral ROMs/Specc_yBoot..., Item,, menu_options_selectroms_peripheral_select,, 10
 Options/Select ROMs/Peripheral ROMs/TT_X2000S..., Item,, menu_options_selectroms_peripheral_select,, 11
 Options/Select ROMs/Peripheral ROMs/_uSource..., Item,, menu_options_selectroms_peripheral_select,, 12
+Options/Select ROMs/Peripheral ROMs/FDD_3000..., Item,, menu_options_selectroms_peripheral_select,, 13
 
 Options/_Filter..., Item,,, menu_filter_detail
 
@@ -158,6 +159,8 @@
 Machine/_NMI, Item
 Machine/Multiface Red _Button, Item
 Machine/Didaktik SNA_P, Item
+Machine/separator, Separator
+Machine/FDD3000 rese_t, Item
 
 M_edia, Branch
 
@@ -395,6 +398,44 @@
 Media/Disk/DISCiPLE/Drive 2/Write protect/_Enable, Item,, menu_media_writeprotect,, 0x152
 Media/Disk/DISCiPLE/Drive 2/Write protect/_Disable, Item,, menu_media_writeprotect,, 0x052
 
+Media/Disk/FDD_3000, Branch
+Media/Disk/FDD3000/Drive _A, Branch,,,menu_fdd3000a_detail
+Media/Disk/FDD3000/Drive A/Insert _New, Item,, menu_media_insert_new,, 0x71
+Media/Disk/FDD3000/Drive A/_Insert..., Item,, menu_media_insert,, 0x71
+Media/Disk/FDD3000/Drive A/_Eject, Item,, menu_media_eject,, 0x71
+Media/Disk/FDD3000/Drive A/_Save, Item,, menu_media_save,, 0x071
+Media/Disk/FDD3000/Drive A/Save _As..., Item,, menu_media_save,, 0x171
+Media/Disk/FDD3000/Drive A/_Flip disk, Branch
+Media/Disk/FDD3000/Drive A/Flip disk/Turn _upside down, Item,, menu_media_flip,, 0x171
+Media/Disk/FDD3000/Drive A/Flip disk/Turn _back, Item,, menu_media_flip,, 0x071
+Media/Disk/FDD3000/Drive _B, Branch,,,menu_fdd3000b_detail
+Media/Disk/FDD3000/Drive B/Insert _New, Item,, menu_media_insert_new,, 0x72
+Media/Disk/FDD3000/Drive B/_Insert..., Item,, menu_media_insert,, 0x72
+Media/Disk/FDD3000/Drive B/_Eject, Item,, menu_media_eject,, 0x72
+Media/Disk/FDD3000/Drive B/_Save, Item,, menu_media_save,, 0x072
+Media/Disk/FDD3000/Drive B/Save _As..., Item,, menu_media_save,, 0x172
+Media/Disk/FDD3000/Drive B/_Flip disk, Branch
+Media/Disk/FDD3000/Drive B/Flip disk/Turn _upside down, Item,, menu_media_flip,, 0x172
+Media/Disk/FDD3000/Drive B/Flip disk/Turn _back, Item,, menu_media_flip,, 0x072
+Media/Disk/FDD3000/Drive _C, Branch,,,menu_fdd3000c_detail
+Media/Disk/FDD3000/Drive C/Insert _New, Item,, menu_media_insert_new,, 0x73
+Media/Disk/FDD3000/Drive C/_Insert..., Item,, menu_media_insert,, 0x73
+Media/Disk/FDD3000/Drive C/_Eject, Item,, menu_media_eject,, 0x73
+Media/Disk/FDD3000/Drive C/_Save, Item,, menu_media_save,, 0x073
+Media/Disk/FDD3000/Drive C/Save _As..., Item,, menu_media_save,, 0x173
+Media/Disk/FDD3000/Drive C/_Flip disk, Branch
+Media/Disk/FDD3000/Drive C/Flip disk/Turn _upside down, Item,, menu_media_flip,, 0x173
+Media/Disk/FDD3000/Drive C/Flip disk/Turn _back, Item,, menu_media_flip,, 0x073
+Media/Disk/FDD3000/Drive _D, Branch,,,menu_fdd3000d_detail
+Media/Disk/FDD3000/Drive D/Insert _New, Item,, menu_media_insert_new,, 0x74
+Media/Disk/FDD3000/Drive D/_Insert..., Item,, menu_media_insert,, 0x74
+Media/Disk/FDD3000/Drive D/_Eject, Item,, menu_media_eject,, 0x74
+Media/Disk/FDD3000/Drive D/_Save, Item,, menu_media_save,, 0x074
+Media/Disk/FDD3000/Drive D/Save _As..., Item,, menu_media_save,, 0x174
+Media/Disk/FDD3000/Drive D/_Flip disk, Branch
+Media/Disk/FDD3000/Drive D/Flip disk/Turn _upside down, Item,, menu_media_flip,, 0x174
+Media/Disk/FDD3000/Drive D/Flip disk/Turn _back, Item,, menu_media_flip,, 0x074
+
 Media/Disk/_Opus, Branch
 Media/Disk/Opus/Drive _1, Branch,,,menu_opus1_detail
 Media/Disk/Opus/Drive 1/Insert _New, Item,, menu_media_insert_new,, 0x41
diff -Naru fuse-1.6.0/menu_data.pl fuse-1.6.0-fdd3000-0.2.1/menu_data.pl
diff -Naru fuse-1.6.0/menu.h fuse-1.6.0-fdd3000-0.2.1/menu.h
--- fuse-1.6.0/menu.h	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/menu.h	2023-08-07 09:56:42.525039930 +0200
@@ -84,6 +84,7 @@
 MENU_CALLBACK( menu_machine_nmi );
 MENU_CALLBACK( menu_machine_multifaceredbutton );
 MENU_CALLBACK( menu_machine_didaktiksnap );
+MENU_CALLBACK( menu_machine_fdd3000reset );
 
 MENU_CALLBACK( menu_media_tape_browse );
 MENU_CALLBACK( menu_media_tape_open );
@@ -149,6 +150,10 @@
 MENU_DETAIL( menu_beta128b_detail );
 MENU_DETAIL( menu_beta128c_detail );
 MENU_DETAIL( menu_beta128d_detail );
+MENU_DETAIL( menu_fdd3000a_detail );
+MENU_DETAIL( menu_fdd3000b_detail );
+MENU_DETAIL( menu_fdd3000c_detail );
+MENU_DETAIL( menu_fdd3000d_detail );
 MENU_DETAIL( menu_opus1_detail );
 MENU_DETAIL( menu_opus2_detail );
 MENU_DETAIL( menu_plusd1_detail );
diff -Naru fuse-1.6.0/missing fuse-1.6.0-fdd3000-0.2.1/missing
diff -Naru fuse-1.6.0/options.h fuse-1.6.0-fdd3000-0.2.1/options.h
diff -Naru fuse-1.6.0/peripherals/disk/fdd3000.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/fdd3000.c
--- fuse-1.6.0/peripherals/disk/fdd3000.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/fdd3000.c	2023-08-07 09:56:42.525039930 +0200
@@ -0,0 +1,198 @@
+/******************************************************************************
+
+ fdd3000.c: The FDD3000 disk station emulator  
+ 
+ This file is part of FDD3000 Emulator version 0.2.0
+
+ Copyright (C) 2018 by Sławomir Szczyrba <sszczyrba@gmail.com>
+
+ FDD300Emu is free software: you can redistribute it and/or modify it under
+ the terms of the GNU Lesser General Public License as published by the Free
+ Software Foundation, either version 2 of the License, or (at your option) any
+ later version.
+
+ This program is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+ details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this program. If not, see <http://www.gnu.org/licenses/lgpl.html>
+
+******************************************************************************/
+
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "fdd3boot.h"
+#include "fdd3000.h"
+#include "z80free/Z80free.h"
+
+static Z80FREE cpuctx, *cpu = &cpuctx;
+static uint8_t fddRAM[65536];
+static int paged, drq;
+static uint8_t fdd2ti, ti2fdd;
+static int counter;
+
+
+void
+wrTI2FDD( uint8_t val )
+{
+  ti2fdd = val;
+}
+
+uint8_t
+rdFDD2TI( void )
+{
+  return fdd2ti;
+}
+
+void
+fddSetFDCInt( uint8_t val )
+{
+  Z80free_INT( cpu, val );
+}
+
+void
+fddClrFDCInt( void )
+{
+  Z80free_INTserved( cpu );
+}
+
+void
+fddSetDRQ( void )
+{
+  drq = 128;
+}
+
+void
+fddClrDRQ( void )
+{
+  drq = 0;
+}
+
+void
+fddReset( void )
+{
+  paged = 1;
+  drq   = 0;
+  Z80free_reset( cpu );
+  counter = 0;
+}
+
+int
+fddCpuStep( void )
+{
+  int tst;
+  tst = Z80free_step( cpu );
+  counter++;
+  if( counter >= 5 ) {
+    tst += Z80free_step( cpu ); counter = 0;
+  }
+  return tst;
+}
+
+int
+fddCpuUStep( void )
+{
+  int tst;
+  tst = Z80free_ustep( cpu );
+  counter++;
+  if( counter >= 5 ) {
+    tst += Z80free_ustep( cpu ); counter = 0;
+  }
+  return tst;
+}
+
+byte
+Z80free_Rd( word Addr )
+{
+  if( paged && ( Addr < 2048 ) ) {
+    return fddROM[Addr];
+  } else return fddRAM[Addr];
+}
+
+void
+Z80free_Wr( word Addr, byte Value )
+{
+  if( ( !paged ) || ( Addr > 2048 ) ) {
+    fddRAM[Addr] = Value;
+  }
+}
+
+void
+writeConfig( uint8_t value )
+{
+  uint8_t val = ( value ^ 0xff ) & 0b10111111;
+  setDriveCfg( val );
+  if( !( value & 0b01000000 ) ) {
+    paged = 1;
+  } else {
+    paged = 0;
+  }
+}
+
+/* ;;;  WD1770
+   ; ------
+   ; C0 - status/command
+   ; C1 - track
+   ; C2 - sector
+   ; C3 - data */
+
+void
+writeFddPort( uint16_t port, uint8_t value )
+{
+  switch( port ) {
+  case 0: wrCommandReg( value );   break;
+  case 1: wrTrackReg( value );     break;
+  case 2: wrSectorReg( value );    break;
+  case 3: wrDataReg( value );      break;
+  }
+}
+
+void
+Z80free_Out( word Port, byte Value )
+{
+  int ioport = ( Port & 0xff ) >> 5;
+  switch( ioport ) {
+  case 0:
+  case 2:
+  case 3:
+  case 4:
+  case 5: break;       /* serial ports are not emulated yet */
+  case 1: fdd2ti = Value;  break;
+  case 6: writeFddPort( Port & 0x0f, Value ); break;
+  case 7: writeConfig( Value ); break;
+  }
+}
+
+uint8_t
+readFddPort( uint16_t port )
+{
+  uint8_t val = 0;
+  switch( port ) {
+  case 0: val = rdStatusReg(); break;
+  case 1: val = rdTrackReg();  break;
+  case 2: val = rdSectorReg(); break;
+  case 3: val = rdDataReg();   break;
+  }
+  return val;
+}
+
+byte
+Z80free_In( word Port )
+{
+  int ioport = ( Port & 0xff ) >> 5;
+  switch( ioport ) {
+  case 0: return 0xff;
+  case 1: return ti2fdd | drq;
+  case 2:
+  case 3:
+  case 4:
+  case 5: return 0xff;        /* serial ports are not emulated yet */
+  case 6: return readFddPort( Port & 0x0f );
+  case 7: return 0xff;        /* write only */
+  }
+  return 0;
+}
diff -Naru fuse-1.6.0/peripherals/disk/fdd3000.h fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/fdd3000.h
--- fuse-1.6.0/peripherals/disk/fdd3000.h	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/fdd3000.h	2023-08-29 12:37:19.190903964 +0200
@@ -0,0 +1,73 @@
+/******************************************************************************
+
+ This file is part of FDD3000 Emulator version 0.2.0
+
+ Copyright (C) 2018 by Sławomir Szczyrba <sszczyrba@gmail.com>
+
+ FDD300Emu is free software: you can redistribute it and/or modify it under
+ the terms of the GNU Lesser General Public License as published by the Free
+ Software Foundation, either version 2 of the License, or (at your option) any
+ later version.
+
+ This program is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+ details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this program. If not, see <http://www.gnu.org/licenses/lgpl.html>
+
+******************************************************************************/
+
+#ifndef FDD3000_H
+#define FDD3000_H
+
+#include <stdint.h>
+#include "z80free/Z80free.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define DEBUG 0
+#define debug_print(fmt, ...) \
+            do { if (DEBUG) fprintf(stderr, fmt, ##__VA_ARGS__); } while (0)
+
+#define FDD3_DRIVE_NONE 0x00
+#define FDD3_DRIVE_0    0x01
+#define FDD3_DRIVE_1    0x02
+#define FDD3_DRIVE_2    0x04
+#define FDD3_DRIVE_3    0x08
+#define FDD3_SIDE_B     0x10
+#define FDD3_DD         0x20
+#define FDD3_HEAD       0x80
+
+void    wrTI2FDD( uint8_t val );
+uint8_t rdFDD2TI( void );
+
+extern void     wrCommandReg( uint8_t val );
+extern void     wrTrackReg( uint8_t val );
+extern void     wrSectorReg( uint8_t val );
+extern void     wrDataReg( uint8_t val );
+
+extern uint8_t  rdStatusReg( void );
+extern uint8_t  rdTrackReg( void );
+extern uint8_t  rdSectorReg( void );
+extern uint8_t  rdDataReg( void );
+
+extern void     setDriveCfg( uint8_t val );
+
+void            fddSetDRQ( void );
+void            fddClrDRQ( void );
+void            fddSetFDCInt( uint8_t val );
+void            fddClrFDCInt( void );
+void            fddReset( void );
+int             fddCpuStep( void );
+int             fddCpuUStep( void );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FDD3000_H */
\ Brak znaku nowej linii na końcu pliku
diff -Naru fuse-1.6.0/peripherals/disk/fdd3boot.h fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/fdd3boot.h
--- fuse-1.6.0/peripherals/disk/fdd3boot.h	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/fdd3boot.h	2023-08-07 09:56:42.528373275 +0200
@@ -0,0 +1,164 @@
+/******************************************************************************
+ 
+ fdd3boot.h: BootROM for the FDD3000 disk station
+
+ This file is part of FDD3000 Emulator version 0.2.0
+
+ FDD300Emu is free software: you can redistribute it and/or modify it under
+ the terms of the GNU Lesser General Public License as published by the Free
+ Software Foundation, either version 2 of the License, or (at your option) any
+ later version.
+
+ This program is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+ details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this program. If not, see <http://www.gnu.org/licenses/lgpl.html>
+
+******************************************************************************/
+
+#ifndef FDD3BOOT_H
+#define FDD3BOOT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static const uint8_t fddROM[]={
+  0xf3,0x31,0xff,0x3e,0x3e,0x00,0xd3,0x20,0x3e,0xd0,0xd3,0xc0,0x3e,0x01,0xcd,0x59,
+  0x00,0xdb,0xc0,0x3e,0x9f,0xd3,0xe0,0x3e,0x97,0xd3,0xe0,0x3e,0x9b,0xd3,0xe0,0x3e,
+  0x9d,0xd3,0xe0,0x3e,0x1e,0xd3,0xe0,0x3e,0x00,0xd3,0xc0,0x06,0x04,0xaf,0xcd,0x59,
+  0x00,0x10,0xfa,0x21,0x00,0x3f,0x0e,0xc3,0x06,0x00,0xdb,0xc0,0xcb,0x57,0x28,0xfa,
+  0xcb,0x47,0x20,0xf6,0xaf,0xd3,0xc2,0x3e,0x8c,0xd3,0xc0,0xdb,0x20,0x17,0x30,0xfb,
+  0xed,0xa2,0x20,0xf7,0xdb,0xc0,0xc3,0x00,0x3f,0xc5,0x06,0x00,0x00,0x10,0xfd,0x3d,
+  0x20,0xf8,0xc1,0xc9,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
+  };
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FDD3BOOT_H */
diff -Naru fuse-1.6.0/peripherals/disk/ti397.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/ti397.c
--- fuse-1.6.0/peripherals/disk/ti397.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/ti397.c	2023-08-07 10:55:56.053308576 +0200
@@ -0,0 +1,549 @@
+/*  ti397.c: Routines for handling the FDD3000 interface 
+    (based on the +D routines)
+
+   Copyright (c) 1999-2016 Stuart Brady, Fredrick Meunier, Philip Kendall,
+   Dmitry Sanarin, Darren Salt, 2014 Gergely Szasz, Sławomir Szczyrba
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+   Author contact information:
+
+   Philip: philip-fuse@shadowmagic.org.uk
+
+   Stuart: stuart.brady@gmail.com
+
+*/
+
+#include <config.h>
+
+#include <libspectrum.h>
+
+#include <string.h>
+
+#include "compat.h"
+#include "debugger/debugger.h"
+#include "infrastructure/startup_manager.h"
+#include "machine.h"
+#include "module.h"
+#include "ti397.h"
+#include "fdd3000.h"
+#include "peripherals/printer.h"
+#include "settings.h"
+#include "ui/ui.h"
+#include "ui/uimedia.h"
+#include "unittests/unittests.h"
+#include "utils.h"
+#include "wd_fdc.h"
+#include "options.h"    /* needed for get combo options */
+#include "z80/z80.h"
+
+/* 8KB ROM */
+#define FDD3000_ROM_SIZE 0x1000
+/* 8KB RAM */
+#define FDD3000_RAM_SIZE 0x2000
+
+static int fdd3000_rom_memory_source, fdd3000_ram_memory_source;
+
+/* Two memory chunks accessible by the Z80 when /ROMCS is low */
+static memory_page fdd3000_memory_map_romcs_rom[ MEMORY_PAGES_IN_8K ];
+static memory_page fdd3000_memory_map_romcs_ram[ MEMORY_PAGES_IN_8K ];
+
+int fdd3000_available = 0;
+int fdd3000_active = 0;
+
+static int current_drv, side_b, head_up, double_density;
+
+wd_fdc *fdd3000_fdc;
+static fdd_t fdd3000_drives[ FDD3000_NUM_DRIVES ];
+static ui_media_drive_info_t fdd3000_ui_drives[ FDD3000_NUM_DRIVES ];
+
+static libspectrum_byte fdd3000_ram[FDD3000_RAM_SIZE];
+
+static void fdd3000_reset( int hard_reset );
+static void fdd3000_memory_map( void );
+static void fdd3000_activate( void );
+
+
+
+static void
+fdd3000_io_write( libspectrum_word port GCC_UNUSED, libspectrum_byte b )
+{
+
+  if( ( port & 0xff ) == 0xef ) {
+    wrTI2FDD( b );
+  }
+}
+
+static libspectrum_byte
+fdd3000_io_read( libspectrum_word port GCC_UNUSED, libspectrum_byte *attached )
+{
+  libspectrum_byte ret = 0;
+  if( ( port & 0xff ) == 0xef ) {
+    *attached = 0xff;
+    ret = rdFDD2TI();
+  }
+  return ret;
+}
+
+static const periph_port_t fdd3000_ports[] = {
+  { 0x00ff, 0x00ef, fdd3000_io_read, fdd3000_io_write },
+  { 0, 0, NULL, NULL }
+};
+
+static module_info_t fdd3000_module_info = {
+
+  /* .reset = */ fdd3000_reset,
+  /* .romcs = */ fdd3000_memory_map,
+  /* .snapshot_enabled = */ 0,
+  /* .snapshot_from = */ 0,
+  /* .snapshot_to = */ 0
+
+};
+
+static const periph_t fdd3000_periph = {
+  /* .option = */ &settings_current.fdd3000,
+  /* .ports = */ fdd3000_ports,
+  /* .hard_reset = */ 1,
+  /* .activate = */ fdd3000_activate
+};
+
+/* Debugger events */
+static const char *const event_type_string = "fdd3000";
+static int page_event, unpage_event;
+
+void
+fdd3000_page( void )
+{
+    debug_print("FDD3 page\n");    
+  fdd3000_active = 1;
+  machine_current->ram.romcs = 1;
+  machine_current->memory_map();
+  debugger_event( page_event );
+}
+
+void
+fdd3000_unpage( void )
+{
+    debug_print("FDD3 unpage\n");
+  fdd3000_active = 0;
+  machine_current->ram.romcs = 0;
+  machine_current->memory_map();
+  debugger_event( unpage_event );
+}
+
+void
+dump_memory_page( memory_page mp )
+{
+  fprintf( stderr, "page ptr  : %p\n", mp.page );
+  fprintf( stderr, "writable  : %d\n", mp.writable );
+  fprintf( stderr, "contended : %d\n", mp.contended );
+  fprintf( stderr, "source    : %d\n", mp.source );
+  fprintf( stderr, "snapshot  : %d\n", mp.save_to_snapshot );
+  fprintf( stderr, "page num  : %d\n", mp.page_num );
+  fprintf( stderr, "offset    : x%04x\n\n", mp.offset );
+}
+
+
+static void
+fdd3000_memory_map( void )
+{
+  if( !fdd3000_active ) return;
+  memory_map_romcs_8k( 0x0000, fdd3000_memory_map_romcs_rom );
+  memory_map_romcs_8k( 0x2000, fdd3000_memory_map_romcs_ram );
+}
+
+static void
+fdd3000_activate( void )
+{
+  debug_print("FDD3 activate\n");;
+}
+
+static void
+fdd3000_set_datarq( struct wd_fdc *f )
+{
+  fddSetDRQ();
+}
+static void
+fdd3000_reset_datarq( struct wd_fdc *f )
+{
+  fddClrDRQ();
+}
+static void
+fdd3000_set_intrq( struct wd_fdc *f )
+{
+  fddSetFDCInt( 0xff );
+}
+static void
+fdd3000_reset_intrq( struct wd_fdc *f )
+{
+  fddClrFDCInt();
+}
+
+static int
+fdd3000_init( void *context )
+{
+  int i;
+  fdd_t *d;
+
+    debug_print("FDD3 init\n");
+
+  fdd3000_fdc = wd_fdc_alloc_fdc( WD1772, 0, WD_FLAG_NONE | WD_FLAG_FDD3000 );
+
+  for( i = 0; i < FDD3000_NUM_DRIVES; i++ ) {
+    d = &fdd3000_drives[ i ];
+    fdd_init( d, FDD_SHUGART, NULL, 0 ); /* drive geometry 'autodetect' */
+    d->disk.flag = DISK_FLAG_NONE;/*|DISK_FLAG_PLUS3_CPC; */
+  }
+
+  fdd3000_fdc->current_drive = &fdd3000_drives[ 0 ];
+  fdd_select( &fdd3000_drives[ 0 ], 1 );
+  fdd3000_fdc->dden = 1;
+  fdd3000_fdc->set_intrq = fdd3000_set_intrq;
+  fdd3000_fdc->reset_intrq = fdd3000_reset_intrq;
+  fdd3000_fdc->set_datarq = fdd3000_set_datarq;
+  fdd3000_fdc->reset_datarq = fdd3000_reset_datarq;
+
+  module_register( &fdd3000_module_info );
+
+  fdd3000_rom_memory_source = memory_source_register( "FDD3000 ROM" );
+  fdd3000_ram_memory_source = memory_source_register( "FDD3000 RAM" );
+
+  for( i = 0; i < MEMORY_PAGES_IN_8K; i++ )
+    fdd3000_memory_map_romcs_rom[i].source = fdd3000_rom_memory_source;
+  for( i = 0; i < MEMORY_PAGES_IN_8K; i++ )
+    fdd3000_memory_map_romcs_ram[i].source = fdd3000_ram_memory_source;
+
+  periph_register( PERIPH_TYPE_FDD3000, &fdd3000_periph );
+
+  for( i = 0; i < FDD3000_NUM_DRIVES; i++ ) {
+    fdd3000_ui_drives[ i ].fdd = &fdd3000_drives[ i ];
+    ui_media_drive_register( &fdd3000_ui_drives[ i ] );
+  }
+
+  periph_register_paging_events( event_type_string, &page_event,
+                                 &unpage_event );
+  ui_menu_activate( UI_MENU_ITEM_MACHINE_FDD3000_RESET, 1 );
+  current_drv = side_b = head_up = double_density = 0;
+  wd_fdc_master_reset( fdd3000_fdc );
+  fddReset();
+
+  for( i = 0; i < FDD3000_NUM_DRIVES; i++ ) {
+    ui_media_drive_update_menus( &fdd3000_ui_drives[ i ],
+                                 UI_MEDIA_DRIVE_UPDATE_ALL );
+  }
+
+  fdd3000_fdc->current_drive = &fdd3000_drives[ 0 ];
+  fdd_select( &fdd3000_drives[ 0 ], 0 );
+  return 0;
+}
+
+static void
+fdd3000_end( void )
+{
+    debug_print("FDD3 end\n");
+  fdd3000_available = 0;
+  libspectrum_free( fdd3000_fdc );
+  ui_menu_activate( UI_MENU_ITEM_MACHINE_FDD3000_RESET, 0 );
+
+}
+
+void
+fdd3000_register_startup( void )
+{
+    debug_print("FDD3 register startup\n");
+  startup_manager_module dependencies[] = {
+    STARTUP_MANAGER_MODULE_DEBUGGER,
+    STARTUP_MANAGER_MODULE_MEMORY,
+    STARTUP_MANAGER_MODULE_SETUID,
+  };
+  startup_manager_register( STARTUP_MANAGER_MODULE_FDD3000, dependencies,
+                            ARRAY_SIZE( dependencies ), fdd3000_init, NULL,
+                            fdd3000_end );
+}
+
+static void
+fdd3000_reset( int hard_reset )
+{
+  int i;
+
+    debug_print("FDD3 reset\n");
+
+  fdd3000_active = 0;
+  fdd3000_available = 0;
+
+  if( !periph_is_active( PERIPH_TYPE_FDD3000 ) ) {
+    ui_menu_activate( UI_MENU_ITEM_MACHINE_FDD3000_RESET, 0 );
+    return;
+  }
+  if( machine_load_rom_bank( fdd3000_memory_map_romcs_rom, 0,
+                             settings_current.rom_fdd3000,
+                             settings_default.rom_fdd3000,
+                             FDD3000_ROM_SIZE ) ) {
+    settings_current.fdd3000 = 0;
+    periph_activate_type( PERIPH_TYPE_FDD3000, 0 );
+    return;
+  }
+  for( i = 0; i < MEMORY_PAGES_IN_4K; i++ ) {
+    fdd3000_memory_map_romcs_rom[ i +
+                                  MEMORY_PAGES_IN_4K ] =
+      fdd3000_memory_map_romcs_rom[ i ];
+  }
+
+  machine_current->ram.romcs = 0;
+
+  for( i = 0; i < MEMORY_PAGES_IN_8K; i++ ) {
+    fdd3000_memory_map_romcs_ram[ i ].page = &fdd3000_ram[i * MEMORY_PAGE_SIZE];
+    fdd3000_memory_map_romcs_ram[ i ].offset = i * MEMORY_PAGE_SIZE;
+    fdd3000_memory_map_romcs_ram[ i ].writable = 1;
+  }
+
+  fdd3000_available = 1;
+
+  if( hard_reset )
+    memset( fdd3000_ram, 0, FDD3000_RAM_SIZE );
+
+  machine_current->memory_map();
+  ui_menu_activate( UI_MENU_ITEM_MACHINE_FDD3000_RESET, 1 );
+}
+
+
+fdd_t *
+fdd3000_get_fdd( fdd3000_drive_number which )
+{
+  return &( fdd3000_drives[ which ] );
+}
+
+int
+fdd3000_unittest( void )
+{
+  int r = 0;
+
+  fdd3000_page();
+
+  r += unittests_assert_4k_page( 0x0000, fdd3000_rom_memory_source, 0 );
+  r += unittests_assert_2k_page( 0x2000, fdd3000_ram_memory_source, 0 );
+  /* FIXME: should we add mirroring at 0x2800, 0x3000 and/or 0x3800? */
+  r += unittests_assert_16k_ram_page( 0x4000, 5 );
+  r += unittests_assert_16k_ram_page( 0x8000, 2 );
+  r += unittests_assert_16k_ram_page( 0xc000, 0 );
+
+  fdd3000_unpage();
+
+  r += unittests_paging_test_48( 2 );
+
+  return r;
+}
+
+static int
+ui_drive_is_available( void )
+{
+  return fdd3000_available;
+}
+
+static const fdd_params_t *
+ui_drive_get_params_1( void )
+{
+  return &fdd_params[ option_enumerate_diskoptions_drive_fdd3000a_type() + 1 ];
+}
+
+static const fdd_params_t *
+ui_drive_get_params_2( void )
+{
+  return &fdd_params[ option_enumerate_diskoptions_drive_fdd3000b_type() ];
+}
+
+static const fdd_params_t *
+ui_drive_get_params_3( void )
+{
+  return &fdd_params[ option_enumerate_diskoptions_drive_fdd3000c_type() ];
+}
+
+static const fdd_params_t *
+ui_drive_get_params_4( void )
+{
+  return &fdd_params[ option_enumerate_diskoptions_drive_fdd3000d_type() ];
+}
+
+int
+fdd3000_disk_insert( fdd3000_drive_number which, const char *filename,
+                     int autoload )
+{
+  if( which >= FDD3000_NUM_DRIVES ) {
+    ui_error( UI_ERROR_ERROR, "fdd3000_disk_insert: unknown drive %d",
+              which );
+    fuse_abort();
+  }
+
+  return ui_media_drive_insert( &fdd3000_ui_drives[ which ], filename,
+                                autoload );
+}
+
+
+static ui_media_drive_info_t fdd3000_ui_drives[ FDD3000_NUM_DRIVES ] = {
+  {
+    /* .name = */ "FDD3000 Disk A",
+    /* .controller_index = */ UI_MEDIA_CONTROLLER_FDD3000,
+    /* .drive_index = */ FDD3000_DRIVE_A,
+    /* .menu_item_parent = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000,
+    /* .menu_item_top = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_A,
+    /* .menu_item_eject = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_A_EJECT,
+    /* .menu_item_flip = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_A_FLIP_SET,
+    /* .menu_item_wp = */ 0,/*UI_MENU_ITEM_MEDIA_DISK_FDD3000_A_WP_SET, */
+    /* .is_available = */ &ui_drive_is_available,
+    /* .get_params = */ &ui_drive_get_params_1,
+  },
+  {
+    /* .name = */ "FDD3000 Disk B",
+    /* .controller_index = */ UI_MEDIA_CONTROLLER_FDD3000,
+    /* .drive_index = */ FDD3000_DRIVE_B,
+    /* .menu_item_parent = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000,
+    /* .menu_item_top = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_B,
+    /* .menu_item_eject = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_B_EJECT,
+    /* .menu_item_flip = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_B_FLIP_SET,
+    /* .menu_item_wp = */ 0,/*UI_MENU_ITEM_MEDIA_DISK_FDD3000_B_WP_SET, */
+    /* .is_available = */ &ui_drive_is_available,
+    /* .get_params = */ &ui_drive_get_params_2,
+  },
+  {
+    /* .name = */ "FDD3000 Disk C",
+    /* .controller_index = */ UI_MEDIA_CONTROLLER_FDD3000,
+    /* .drive_index = */ FDD3000_DRIVE_C,
+    /* .menu_item_parent = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000,
+    /* .menu_item_top = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_C,
+    /* .menu_item_eject = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_C_EJECT,
+    /* .menu_item_flip = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_C_FLIP_SET,
+    /* .menu_item_wp = */ 0,/*UI_MENU_ITEM_MEDIA_DISK_FDD3000_C_WP_SET, */
+    /* .is_available = */ &ui_drive_is_available,
+    /* .get_params = */ &ui_drive_get_params_3,
+  },
+  {
+    /* .name = */ "FDD3000 Disk D",
+    /* .controller_index = */ UI_MEDIA_CONTROLLER_FDD3000,
+    /* .drive_index = */ FDD3000_DRIVE_D,
+    /* .menu_item_parent = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000,
+    /* .menu_item_top = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_D,
+    /* .menu_item_eject = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_D_EJECT,
+    /* .menu_item_flip = */ UI_MENU_ITEM_MEDIA_DISK_FDD3000_D_FLIP_SET,
+    /* .menu_item_wp = */ 0,/*UI_MENU_ITEM_MEDIA_DISK_FDD3000_D_WP_SET, */
+    /* .is_available = */ &ui_drive_is_available,
+    /* .get_params = */ &ui_drive_get_params_4,
+  },
+};
+
+/*
+; bit 0 - /select drive 0
+; bit 1 - /select drive 1
+; bit 2 - /select drive 2
+; bit 3 - /select drive 3
+; bit 4 - select side A-/B
+; bit 5 - double density /DDEN
+; bit 6 - select /BOOTROM
+; bit 7 - /head up ( 0 - głowica aktywna-leży na dyskietce, 1 - głowica nieaktywna-w powietrzu)
+*/
+
+
+void
+setDriveCfg( uint8_t val )
+{
+  int drv = val & 0x0f;
+
+  switch( drv ) {
+  case FDD3_DRIVE_NONE: current_drv = 4; break;
+  case FDD3_DRIVE_0: current_drv = 0; break;
+  case FDD3_DRIVE_1: current_drv = 1; break;
+  case FDD3_DRIVE_2: current_drv = 2; break;
+  case FDD3_DRIVE_3: current_drv = 3; break;
+  }
+  if( val & FDD3_SIDE_B ) {
+    side_b = 1;
+  } else {
+    side_b = 0;
+  }
+  if( val & FDD3_DD ) {
+    double_density = 1;
+  } else {
+    double_density = 0;
+  }
+  if( val & FDD3_HEAD ) {
+    head_up = 1;
+  } else {
+    head_up = 0;
+  }
+
+  if( current_drv < 4 ) {/* */
+    fdd_motoron( fdd3000_fdc->current_drive, 1 );
+    fdd_head_load( fdd3000_fdc->current_drive, 1 );
+    fdd_select( fdd3000_fdc->current_drive, 0 );
+    fdd3000_fdc->dden = double_density;
+
+    fdd3000_fdc->current_drive = &fdd3000_drives[ current_drv ];
+    fdd_select( fdd3000_fdc->current_drive, 1 );
+    fdd_set_head( fdd3000_fdc->current_drive, side_b );
+    fdd_head_load( fdd3000_fdc->current_drive, head_up );
+    /* fdd_motoron(fdd3000_fdc->current_drive, 1);
+       fdd3000_fdc->current_drive->unreadable=(current_drv==4);	// */
+  } else {   /* */
+    fdd_select( fdd3000_fdc->current_drive, 0 );       /* */
+  }   /* */
+}
+
+void
+wrCommandReg( uint8_t val )
+{
+  wd_fdc_cr_write( fdd3000_fdc, val );
+}
+
+void
+wrTrackReg( uint8_t val )
+{
+  wd_fdc_tr_write( fdd3000_fdc, val );
+}
+
+void
+wrSectorReg( uint8_t val )
+{
+  wd_fdc_sec_write( fdd3000_fdc, val );
+}
+
+void
+wrDataReg( uint8_t val )
+{
+  wd_fdc_dr_write( fdd3000_fdc, val );
+}
+
+uint8_t
+rdStatusReg( void )
+{
+  return wd_fdc_sr_read( fdd3000_fdc );
+}
+
+uint8_t
+rdTrackReg( void )
+{
+  return wd_fdc_tr_read( fdd3000_fdc );
+}
+
+uint8_t
+rdSectorReg( void )
+{
+  return wd_fdc_sec_read( fdd3000_fdc );
+}
+
+uint8_t
+rdDataReg( void )
+{
+  return wd_fdc_dr_read( fdd3000_fdc );
+}
+
diff -Naru fuse-1.6.0/peripherals/disk/ti397.h fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/ti397.h
--- fuse-1.6.0/peripherals/disk/ti397.h	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/ti397.h	2023-08-07 09:56:42.528373275 +0200
@@ -0,0 +1,78 @@
+/* ti397.h: Routines for handling the FDD3000 interface
+   (based on the +D routines)
+
+   Copyright (c) 1999-2016 Stuart Brady, Fredrick Meunier, Philip Kendall,
+   Dmitry Sanarin, Darren Salt, 2014 Gergely Szasz, Sławomir Szczyrba
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+   Author contact information:
+
+   Philip: philip-fuse@shadowmagic.org.uk
+
+   Stuart: stuart.brady@gmail.com
+
+*/
+
+#ifndef TI397_H
+#define TI397_H
+
+typedef enum fdd3000_drive_number {
+  FDD3000_DRIVE_A = 0,
+  FDD3000_DRIVE_B,
+  FDD3000_DRIVE_C,
+  FDD3000_DRIVE_D,
+  FDD3000_NUM_DRIVES,
+} fdd3000_drive_number;
+
+#include <libspectrum.h>
+
+#include "fdd.h"
+#include "wd_fdc.h"
+
+extern int fdd3000_available;  /* Is the FDD3000 available for use? */
+extern int fdd3000_active;     /* FDD3000 enabled? */
+
+void fdd3000_register_startup( void );
+
+void fdd3000_page( void );
+void fdd3000_unpage( void );
+
+int fdd3000_disk_insert( fdd3000_drive_number which, const char *filename,
+                         int autoload );
+int fdd3000_disk_eject( fdd3000_drive_number which );
+int fdd3000_disk_save(  fdd3000_drive_number which, int saveas );
+int fdd3000_disk_write( fdd3000_drive_number which, const char *filename );
+int fdd3000_disk_flip(  fdd3000_drive_number which, int flip );
+int fdd3000_disk_writeprotect( fdd3000_drive_number which, int wrprot );
+fdd_t *fdd3000_get_fdd( fdd3000_drive_number which );
+
+int fdd3000_unittest( void );
+
+void    wrCommandReg( uint8_t val );
+void    wrTrackReg( uint8_t val );
+void    wrSectorReg( uint8_t val );
+void    wrDataReg( uint8_t val );
+
+uint8_t rdStatusReg( void );
+uint8_t rdTrackReg( void );
+uint8_t rdSectorReg( void );
+uint8_t rdDataReg( void );
+
+void    setDriveCfg( uint8_t val );
+
+extern wd_fdc *fdd3000_fdc;
+
+#endif                  /* #ifndef TI397_H */
diff -Naru fuse-1.6.0/peripherals/disk/wd_fdc.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/wd_fdc.c
--- fuse-1.6.0/peripherals/disk/wd_fdc.c	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/wd_fdc.c	2023-08-07 09:56:42.528373275 +0200
@@ -411,7 +411,7 @@
 	}
       } else
         f->id_mark = WD_FDC_AM_NONE;
-      i = d->disk.bpt ? ( d->disk.i - i ) * 200 / d->disk.bpt : 200;
+      i = d->disk.bpt ? ( d->disk.i - i ) * 200 / d->disk.bpt : (f->flags&WD_FLAG_FDD3000)?3:200;
       if( i > 0 ) {
         event_add_with_data( tstates + i *		/* i * 1/20 revolution */
 			   machine_current->timings.processor_speed / 1000,
@@ -570,8 +570,10 @@
       } else {
         f->id_mark = WD_FDC_AM_NONE;
       }
+// disk procedure reads only sector by sector
+// cheat to hide fact, that we ignore interleave (TOS - 7 sectors, CP/M - 5 sectors)
       i = d->disk.bpt ?
-	( d->disk.i - i ) * 200 / d->disk.bpt : 200;
+	( d->disk.i - i ) * ((f->flags&WD_FLAG_FDD3000)?20:200) / d->disk.bpt : (f->flags&WD_FLAG_FDD3000)?3:200;
       if( i > 0 ) {
         event_add_with_data( tstates + i *		/* i * 1/20 revolution */
 			     machine_current->timings.processor_speed / 1000,
@@ -726,7 +728,7 @@
         i = d->disk.i >= d->disk.bpt ? 0 : d->disk.i;	/* start position */
         read_id( f );
         i = d->disk.bpt ?
-	    ( d->disk.i - i ) * 200 / d->disk.bpt : 200;
+	    ( d->disk.i - i ) * 200 / d->disk.bpt : (f->flags&WD_FLAG_FDD3000)?3:200;
 	if( i > 0 ) {
           event_add_with_data( tstates + i *		/* i * 1/20 revolution */
 			       machine_current->timings.processor_speed / 1000,
diff -Naru fuse-1.6.0/peripherals/disk/wd_fdc.h fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/wd_fdc.h
--- fuse-1.6.0/peripherals/disk/wd_fdc.h	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/wd_fdc.h	2023-08-07 09:56:42.528373275 +0200
@@ -58,7 +58,9 @@
    * 'extra_signal' for this */
   WD_FLAG_RDY       = 1<<2,
   /* HLT (input) pin not connected at all, so we assume it is always 1. */
-  WD_FLAG_NOHLT     = 1<<3
+  WD_FLAG_NOHLT     = 1<<3,
+  /* FDD3000 */
+  WD_FLAG_FDD3000   = 1<<4
 };
 
 typedef enum wd_type_t {
diff -Naru fuse-1.6.0/peripherals/disk/z80free/COPYING fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/COPYING
--- fuse-1.6.0/peripherals/disk/z80free/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/COPYING	2023-08-07 09:56:42.528373275 +0200
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff -Naru fuse-1.6.0/peripherals/disk/z80free/README.txt fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/README.txt
--- fuse-1.6.0/peripherals/disk/z80free/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/README.txt	2023-08-07 09:56:42.531706621 +0200
@@ -0,0 +1,247 @@
+Z80Free
+A free Z80 emulator
+
+
+DISCLAIMER
+
+Z80free is distributed under the GPL license, version three or later, which
+means that is distributed "as is", without warraty of any kind. To know more
+details, read the file COPYING.
+
+
+WHAT IS Z80free?
+
+Z80free is a Z80 emulator written in C. It's designed to be as accurate as
+possible, mainly in the flags from the F register, the instruction set
+(emulating all the oficial and unoficial instructions like SET n,(IX+10h),r
+the phantom IN, incorrect FD and DD sequences...) and the R register. It also
+aims to allow a very accurate emulation of the computer hardware by dividing
+the instructions as finely as possible; that way the prefixes, when
+available, are executed in a first round, and only then the instruction
+itself is executed. This allows a much more precise emulation of incorrect
+sequences of prefixes like FDFDFDFDxx... and others.
+
+
+WORKING WITH Z80FREE
+
+The heart is the typedef struct Z80FREE, which contains all the registers and
+some variables needed to maintain the current state.
+
+typedef struct {
+	Z80FRegs Rm;		/** Main register set (R) */
+	Z80FRegs Ra;		/** Alternate register set (R') */
+	word	PC;			/** Program counter */
+	byte	R;			/** Refresh */
+	byte	R2;			/** Upper bit for Refresh */
+	byte	I;
+	byte	IFF1;		/** Interrupt Flipflop 1. If it's 2
+							decrement it and don't allow INT */
+	byte	IFF2;		/** Interrupt Flipflop 2 */
+	byte	IM;			/** Interrupt mode */
+	byte	HALT;		/** HALT status */
+	byte	INT_P;		/** INT pending */
+	byte	NMI_P;		/** NMI pending */
+	byte	empty_bus;	/** value for empty bus when procesing
+							a maskable int */
+	word	IAddr;		/** address with offset for IX+d and IY+d */
+	byte	IAddr_done;	/** if 1, IAddr contains a valid data */
+	enum {Z80XX, Z80CB, Z80DD, Z80ED, Z80FD, Z80INT} Status;
+} Z80FREE;
+
+The first two elements, Rm and Ra, contains the main and alternate register
+sets. The typedef is the following:
+
+typedef union {
+	/** Word registers. */
+	struct
+	{
+		word AF, BC, DE, HL, IX, IY, SP;
+	} wr;
+	
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	struct
+	{
+		byte F,A, C,B, E,D, L,H, IXl,IXh, IYl,IYh, P,S;
+	} br;
+#else
+	struct
+	{
+		byte A,F, B,C, D,E, H,L, IXh,IXl, IYh,IYl, S,P;
+	} br;
+#endif
+
+} Z80FRegs;
+
+This means that accessing a register (like HL) is done with
+
+	processor.Rm.wr.HL
+
+while accessing a register like H in 8bit mode is done with
+
+	processor.Rm.br.H
+
+Since Z80FRegs is an union, both structs are solaped. The conditional
+#if __BYTE_ORDER == __LITTLE_ENDIAN allows to set the right register
+order depending on the endiannes of the machine.
+
+The register R is stored twice: as R and R2, but only R is incremented after
+each instruction or prefix. When reading it (with LD A,R), the value is
+composed with (R&0x7F)|(R2&0x80). That way the true value is returned,
+since the real Z80 only increment the lower 7 bits of R, but stores all the
+8 bits.
+
+IFF1 and IFF2 are modified by DI and EI. But IFF1 can be 0, 1 or 2. When its
+2, it means that the interrups have to be allowed after the next instruction.
+This is because, when doing
+
+	...
+	EI
+	XXX
+	YYY
+	...
+
+if an interrupt arrives during EI, it won't be accepted between EI and XXX,
+but between XXX and YYY. When IFF1 is 2, Z80FREE won't still accept
+interrupts, but will decrement it, so at the next instruction it will be 1,
+accepting the pending interrupt.
+
+IM can be 0, 1 or 2, but currently modes 0 and 1 are the same (they both jump
+to 38h).
+
+When HALT is 1, the processor is running a HALT instruction, returning 4
+tstates consumed and maintaining the PC counter until an interrupt is
+accepted (or a reset is done).
+
+All the other info is internal and should not be needed when creating an
+emulator.
+
+There are four functions offered by Z80FREE to interact with it:
+
+	void Z80free_reset(Z80FREE *);
+
+RESET function resets the processor.
+
+	void Z80free_INT(Z80FREE *,byte);
+
+INT triggers a maskable interrupt. The BYTE value contains the value
+currently present in the bus (useful when, in a future, the true IM0
+mode will be implemented).
+
+	int Z80free_step(Z80FREE *);
+
+Runs the processor for one complete instruction. It returns the number of
+TSTates used by that instruction. After it, the PC points to the next
+instruction, and is safe to do operations like creating snapshots or
+similar.
+
+	int Z80free_ustep(Z80FREE *);
+
+Runs the processor for a microstep. That means that, if the current
+instruction has a prefix, only the prefix will be recognized, and the
+PC will point to the middle of the instruction; but if the instruction
+doesn't have a prefix, it will run it complete. It returns the TSTates
+used to run that piece of the current instruction. It's unsafe to create
+an snapshot after running this function because the processor can be
+in an intermediate state, but is safe to update the hardware (like the
+screen or the sound).
+
+To know when is safe to do things, a piece of code like this one can
+be used:
+
+while (1) {
+
+	do {
+		// Insecure zone. Only update the hardware
+		tstados=Z80free_ustep(&procesador);
+		EMULATE(tstados);
+	} while(procesador.Status!=Z80XX);
+
+	// Secure zone. Do snapshots and other things that
+	// require the Z80 to be in a defined state.
+	...
+}
+
+Here is assumed that EMULATE(int) emulates the screen, sound,... for
+that number of TSTates. When STATUS is Z80XX, the processor is going
+to read the first byte of an instruction, and is safe to do other things
+like creating snapshots.
+
+Of course, if you don't want to complicate things, just use Z80FREE_STEP.
+
+Finally, you must implement the following functions in order to emulate the
+hardware itself:
+
+	byte Z80free_Rd (word Addr);
+
+When Z80Free needs to read a byte from memory, it will call this function.
+It must return the value contained in the possition ADDR.
+
+	void Z80free_Wr (word Addr, byte Value);
+
+When Z80Free needs to write a byte to memory, it will call this funcion.
+It must store the data VALUE at the position ADDR.
+
+	byte Z80free_In (word Port);
+
+When Z80Free needs to access to an input port, it will call this function.
+PORT contains the 16bit port being accessed.
+
+	void Z80free_Out (word Port, byte Value);
+
+When Z80Free needs to access to an output port, it will call this function.
+PORT contains the 16bit port being accessed, and VALUE the data to be
+written to the port.
+
+
+HOW Z80FREE IS IMPLEMENTED
+
+There are two main files: Z80FREE.C and Z80FREE.H. Z80FREE.C contains the main
+loop and some help functions. Some of them were extracted from LibZ80 (from
+Gabriel Gambetta), adapted to the new processor structure and, where needed,
+fixed some little bugs.
+
+But the true magic is in the files z80FREE_CODESXXXX.C. These files contains
+big switch/case functions which plays each Z80 instruction and returns the
+number of TSTATES used by them. But these files weren't created "by hand",
+but parsing the files Z80FREE_CODESXXXX.TXT. These files contains a list of
+all the Z80 instructions, with its opcode numbers and the number of TSTATES
+used (when it's a conditional instruction, which can use more TSTATES when
+true than when false, it contain both values), and are parsed by the program
+Z80FREE_GENCODE.PY.
+
+This program gets the opcode, the number of TSTATES and the instruction.
+Then it splits the instruction in the instruction itself (like LD, or EX) and
+parameters (like A or 5). With all that data it generates the code for that
+instruction in the right CASE statement.
+
+The code in Z80FREE_GENCODE.PY is divided in several classes, so is extremely
+easy to adapt it to other processors. Just read the comments (you should use
+the GENERIC_PARSER class "as is", and create a new class which inherits from
+it and implements the methods GET_CODE_FROM_ONE_PARAM, CREATE_CODE,
+WRITE_START_CODE and WRITE_END_CODE.
+
+In order to simplify the parser, the syntax of some instructions have been
+modified, like the I/O ones: instead of (C) we use [BC].
+
+If an instruction is incorrectly implemented, you must fix it in
+Z80FREE_GENCODE.PY, run it again to regenerate the .C files, and only then
+recompile your emulator.
+
+The big advantage of this method is that, if the implementation of one
+instruction type is incorrect, fixing it once will fix it in all the
+instructions with all the access modes used. An example: if the LD
+instruction type has a bug, fixing it will fix all the LD instructions, like
+LD A,n, LD (HL),A, LD B,C... The same when the bug is in the parameter code:
+if there's an error in the code that implements (HL) as writing, fixing it
+will fix all the instructions that uses it, like LD (HL),A, or CP (HL).
+
+
+CONTACTING THE AUTHOR
+
+This program is
+(C) 2008 Sergio Costas Rodriguez
+(Raster Software Vigo)
+
+raster@rastersoft.com
+http://www.rastersoft.com
+
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free.c
--- fuse-1.6.0/peripherals/disk/z80free/Z80free.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free.c	2023-08-07 09:56:42.531706621 +0200
@@ -0,0 +1,820 @@
+/*
+ * Copyright 2008-2009 (C) Raster Software Vigo (Sergio Costas)
+ * This file is part of Z80Free, with some bits extracted
+ * and fixed from libZ80 (from Gabriel Gambetta)
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "Z80free.h"
+
+void Z80free_reset(Z80FREE *processor) {
+
+	processor->PC=0;
+	processor->IFF1=0;
+	processor->IFF2=0;
+	processor->Rm.wr.AF=0xFFFF;
+	processor->Rm.wr.BC=0xFFFF;
+	processor->Rm.wr.DE=0xFFFF;
+	processor->Rm.wr.HL=0xFFFF;
+	processor->Rm.wr.IX=0xFFFF;
+	processor->Rm.wr.IY=0xFFFF;
+	processor->Ra.wr.AF=0xFFFF;
+	processor->Ra.wr.BC=0xFFFF;
+	processor->Ra.wr.DE=0xFFFF;
+	processor->Ra.wr.HL=0xFFFF;
+	processor->HALT=0;
+	processor->IM=0;
+	processor->I=0;
+	processor->Status=Z80XX;
+	processor->IAddr_done=0;
+	processor->INT_P=0;
+	processor->NMI_P=0;
+
+}
+
+void Z80free_INT(Z80FREE *processor,byte value) {
+
+	processor->INT_P=1;
+	processor->empty_bus=value;
+}
+
+void Z80free_INTserved(Z80FREE *processor) {
+	processor->INT_P=0;
+}
+
+int Z80free_step(Z80FREE *processor) {
+
+	int retval=0;
+	do {
+		retval+=Z80free_ustep(processor);
+	} while(processor->Status!=Z80XX);
+	return (retval);
+}
+
+int Z80free_ustep(Z80FREE *processor) {
+
+	static byte opcode,d1;
+	int retval=0;
+
+	processor->M1 = true;
+	processor->subtstates = 0;
+	processor->R++;
+	if (processor->Status==Z80XX) {
+		if (processor->NMI_P) { // NMI triggered
+			if (processor->HALT) {
+				processor->HALT=0;
+				processor->PC++;
+			}
+			processor->NMI_P=0;
+			processor->subtstates += 5;
+			processor->IFF1=0; // disable INTs
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=0x0066;
+			processor->Status=Z80INT;
+			return(11); // we use 11 tstates for attending a NMI
+		}
+		if (processor->INT_P) {
+			if (processor->IFF1==1) { // allow INTs only in this case
+				if (processor->HALT) {
+					processor->HALT=0;
+					processor->PC++;
+				}
+				processor->Status=Z80INT;
+				processor->IFF1=0;
+				processor->IFF2=0;
+				processor->subtstates += 7;
+				Z80free_doPush(processor,processor->PC);
+				if (processor->IM != 2) { // we will forget IM0 mode for now; maybe in the future...
+					processor->PC = 0x0038;
+					return (13);
+				} else {
+					processor->PC=Z80free_read16(processor, ((((word)processor->I)<<8)&0xFF00) | ((word)processor->empty_bus));
+					return (19);
+				}
+			}
+		}
+	}
+
+	if (processor->IFF1>1) // set the right status for interrupts
+		processor->IFF1--;
+
+	opcode=Z80free_Rd(processor->PC);
+	processor->subtstates += 4; // 4 tstates are needed to read the opcode
+	processor->PC++;
+	switch(processor->Status) {
+	case Z80INT:
+		processor->Status=Z80XX;
+	case Z80XX:
+		if (opcode==0xCB) {
+			processor->Status=Z80CB;
+			return 4;
+		} else if (opcode==0xED) {
+			processor->Status=Z80ED;
+			return 4;
+		} else if (opcode==0xDD) {
+			processor->Status=Z80DD;
+			return 4;
+		} else if (opcode==0xFD) {
+			processor->Status=Z80FD;
+			return 4;
+		} else {
+			processor->M1 = false;
+			return(Z80free_codes(processor,opcode));
+		}
+	break;
+	case Z80CB:
+		processor->Status=Z80XX;
+		processor->M1 = false;
+		return(Z80free_codesCB(processor,opcode));
+	break;
+	case Z80ED:
+		processor->Status=Z80XX;
+		processor->M1 = false;
+		return(Z80free_codesED(processor,opcode));
+	break;
+	case Z80DD:
+		if (opcode==0xDD) {
+			return 4;
+		}
+		if (opcode==0xFD) {
+			processor->Status=Z80FD;
+			return 4;
+		}
+		processor->Status=Z80XX;
+		if (opcode==0xCB) {
+			d1=Z80free_Rd(processor->PC++);
+			processor->subtstates += 8; // 8 tstates are needed: 3 to read the d value and 5 internal
+			processor->M1 = false;
+			retval+=Z80free_codesDDCB(processor,d1);
+		} else {
+			processor->M1 = false;
+			retval+=Z80free_codesDD(processor,opcode);
+		}
+		processor->IAddr_done=0;
+		return (retval);
+	break;
+	case Z80FD:
+		if (opcode==0xDD) {
+			processor->Status=Z80DD;
+			return 4;
+		}
+		if (opcode==0xFD) {
+			return 4;
+		}
+		processor->Status=Z80XX;
+		if (opcode==0xCB) {
+			d1=Z80free_Rd(processor->PC++);
+			processor->subtstates += 8; // 8 tstates are needed: 3 to read the d value and 5 internal
+			processor->M1 = false;
+			retval+=Z80free_codesFDCB(processor,d1);
+		} else {
+			processor->M1 = false;
+			retval+=Z80free_codesFD(processor,opcode);
+		}
+		processor->IAddr_done=0;
+		return (retval);
+	break;
+	}
+	return 0;
+}
+
+byte Z80free_Rd_Internal (Z80FREE *processor,word Addr) {
+	byte value = Z80free_Rd(Addr);
+	processor->subtstates += 3;
+	return value;
+}
+
+void Z80free_Wr_Internal (Z80FREE *processor,word Addr, byte Value) {
+	Z80free_Wr(Addr,Value);
+	processor->subtstates += 3;
+}
+
+byte Z80free_In_Internal (Z80FREE *processor,word Port) {
+	byte value = Z80free_In(Port);
+	processor->subtstates += 4;
+	return value;
+}
+
+void Z80free_Out_Internal (Z80FREE *processor,word Port, byte Value) {
+	Z80free_Out(Port,Value);
+	processor->subtstates += 4;
+}
+
+/* ---------------------------------------------------------
+ *  Flag operations
+ * ---------------------------------------------------------
+ */
+
+/** Sets a flag */
+void  Z80free_setFlag(Z80FREE *processor, byte flag) {
+
+	processor->Rm.br.F |= flag;
+}
+
+/** Resets a flag */
+void Z80free_resFlag(Z80FREE *processor, byte flag) {
+
+	processor->Rm.br.F &= ~flag;
+}
+
+/** Puts a value in a flag */
+void Z80free_valFlag(Z80FREE *processor, byte flag, int val) {
+
+	if (val)
+		processor->Rm.br.F |= flag;
+	else
+		processor->Rm.br.F &= ~flag;
+}
+
+/** Returns a flag */
+int Z80free_getFlag(Z80FREE *processor, byte flag) {
+
+	return (processor->Rm.br.F & flag) != 0;
+}
+
+
+/* ---------------------------------------------------------
+ *  Flag adjustments
+ * ---------------------------------------------------------
+ */
+
+int Z80free_parityBit[256] = {
+
+	1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+	0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+	0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+	1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+	0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+	1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+	1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+	0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+	0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+	1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+	1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+	0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+	1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
+	0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+	0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
+	1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1 };
+
+
+void Z80free_adjustFlags (Z80FREE *processor, byte val) {
+
+	Z80free_valFlag(processor,F_5, (val & F_5) != 0);
+	Z80free_valFlag(processor,F_3, (val & F_3) != 0);
+}
+
+
+void Z80free_adjustFlagSZP (Z80FREE *processor, byte val) {
+
+	Z80free_valFlag(processor,F_S, (val & 0x80) != 0);
+	Z80free_valFlag(processor,F_Z, (val == 0));
+	Z80free_valFlag(processor,F_PV, Z80free_parityBit[val]);
+}
+
+
+// Adjust flags after AND, OR, XOR
+void Z80free_adjustLogicFlag (Z80FREE *processor, int flagH) {
+
+	Z80free_valFlag(processor,F_S, (processor->Rm.br.A & 0x80) != 0);
+	Z80free_valFlag(processor,F_Z, (processor->Rm.br.A == 0));
+	Z80free_valFlag(processor,F_H, flagH);
+	Z80free_valFlag(processor,F_N, 0);
+	Z80free_valFlag(processor,F_C, 0);
+	Z80free_valFlag(processor,F_PV, Z80free_parityBit[processor->Rm.br.A]);
+
+	Z80free_adjustFlags(processor, processor->Rm.br.A);
+}
+
+
+/* ---------------------------------------------------------
+ *  Generic operations
+ * ---------------------------------------------------------
+ */
+
+byte Z80free_readR(Z80FREE *processor) {
+	Z80free_adjustFlagSZP(processor,(0x7F&processor->R)|(0x80&processor->R2));
+	Z80free_valFlag(processor,F_PV,processor->IFF2);
+	Z80free_valFlag(processor,F_N, 0);
+	Z80free_valFlag(processor,F_H, 0);
+	Z80free_adjustFlags(processor,(0x7F&processor->R)|(0x80&processor->R2));
+	return ((0x7F&processor->R)|(0x80&processor->R2));
+}
+
+void Z80free_setR(Z80FREE *processor,byte value) {
+	processor->R=value;
+	processor->R2=value;
+}
+
+byte Z80free_readI(Z80FREE *processor) {
+
+	Z80free_adjustFlagSZP(processor,processor->I);
+	Z80free_valFlag(processor,F_PV,processor->IFF2);
+	Z80free_valFlag(processor,F_N, 0);
+	Z80free_valFlag(processor,F_H, 0);
+	Z80free_adjustFlags(processor,processor->I);
+	return (processor->I);
+}
+
+
+/** Do an arithmetic operation (ADD, SUB, ADC, SBC y CP) */
+byte Z80free_doArithmetic (Z80FREE *processor, byte value1,byte value2, int withCarry, int isSub) {
+
+	static word res; /* To detect carry */
+	static byte carry;
+
+	if (withCarry && Z80free_getFlag(processor,F_C))
+		carry=1;
+	else
+		carry=0;
+
+	if (isSub) {
+		Z80free_setFlag(processor,F_N);
+		res = ((word)value1) - ((word)value2) - ((word)carry);
+		Z80free_valFlag(processor,F_H, ((value1 ^ value2 ^ res) & 0x10) != 0);
+		Z80free_valFlag(processor,F_PV, (((value1 ^ value2)&0x080) && (((res^value1)&0x080))));
+	} else {
+		Z80free_resFlag(processor,F_N);
+		res = ((word)value1) + ((word)value2) + ((word)carry);
+		Z80free_valFlag(processor,F_H, (((value1 & 0x0F) + (value2 & 0x0F)+carry) & 0x10) != 0);
+		Z80free_valFlag(processor,F_PV, ((((value1 ^ value2)&0x080)==0) && ((res^value1)&0x080)));
+	}
+
+	Z80free_valFlag(processor,F_S, ((res & 0x080) != 0));
+	Z80free_valFlag(processor,F_C, ((res & 0x0100) != 0));
+	Z80free_valFlag(processor,F_Z, ((res&0xFF) == 0));
+
+	Z80free_adjustFlags(processor, res&0xFF);
+
+	return (byte)(res & 0xFF);
+}
+
+word Z80free_doArithmetic16 (Z80FREE *processor, word value1,word value2, int withCarry, int isSub) {
+
+	static word tmp;
+	static byte Ftmp;
+
+	Ftmp=processor->Rm.br.F; // store the F register to restore the unchanged bits when doing operations without carry
+
+	tmp=(word)Z80free_doArithmetic(processor,(byte)(value1&0x00FF),(byte)(value2&0x00FF),withCarry,isSub);
+	tmp|=((word)Z80free_doArithmetic(processor,(byte)((value1>>8)&0x00FF),(byte)((value2>>8)&0x00FF),1,isSub))<<8;
+	if (tmp) {
+		Z80free_resFlag(processor,F_Z);
+	} else {
+		Z80free_setFlag(processor,F_Z);
+	}
+
+	if (tmp&0x08000) {
+		Z80free_setFlag(processor,F_S);
+	} else {
+		Z80free_resFlag(processor,F_S);
+	}
+
+	if (!(withCarry|isSub)) {
+		processor->Rm.br.F &= 0x3B; // preserve the new values of C, N, 3, H and 5
+		processor->Rm.br.F |= (Ftmp & 0xC4); // set the old values of P/V, Z and S
+	}
+
+	return (tmp);
+}
+
+void Z80free_doAND (Z80FREE *processor, byte value) {
+
+	processor->Rm.br.A &= value;
+	Z80free_adjustLogicFlag(processor, 1);
+}
+
+
+void Z80free_doOR (Z80FREE *processor, byte value) {
+
+	processor->Rm.br.A |= value;
+	Z80free_adjustLogicFlag(processor, 0);
+}
+
+
+void Z80free_doXOR (Z80FREE *processor, byte value) {
+
+	processor->Rm.br.A ^= value;
+	Z80free_adjustLogicFlag(processor, 0);
+}
+
+
+void Z80free_doBIT (Z80FREE *processor, int b, byte val) {
+
+	if (val & (1 << b))
+		Z80free_resFlag(processor,F_Z | F_PV);
+	else
+		Z80free_setFlag(processor,F_Z | F_PV);
+
+	Z80free_setFlag(processor,F_H);
+	Z80free_resFlag(processor,F_N);
+
+	if ((b == 7) && !Z80free_getFlag(processor,F_Z))
+		Z80free_setFlag(processor,F_S);
+	else
+		Z80free_resFlag(processor,F_S);
+
+	/*Z80free_resFlag(processor,F_5);
+	if ((b == 5) && !Z80free_getFlag(processor,F_Z))
+		Z80free_setFlag(processor,F_5);
+
+	Z80free_resFlag(processor,F_3);
+	if ((b == 3) && !Z80free_getFlag(processor,F_Z))
+		Z80free_setFlag(processor,F_3);*/
+	Z80free_adjustFlags(processor,val);
+}
+
+
+byte Z80free_doSetRes (Z80FREE *processor, int bit, int pos, byte val) {
+
+	if (bit)
+		val |= (1 << pos);
+	else
+		val &= ~(1 << pos);
+	return val;
+}
+
+
+
+byte Z80free_doIncDec (Z80FREE *processor, byte val, int isDec) {
+
+	if (isDec) {
+		Z80free_valFlag(processor,F_PV, (val & 0x80) && !((val - 1) & 0x80));
+		val--;
+		Z80free_valFlag(processor,F_H, (val & 0x0F)==0x0F);
+	} else {
+		Z80free_valFlag(processor,F_PV, !(val & 0x80) && ((val + 1) & 0x80));
+		val++;
+		Z80free_valFlag(processor,F_H, (val & 0x0F)==0);
+	}
+
+	Z80free_valFlag(processor,F_S, ((val & 0x80) != 0));
+	Z80free_valFlag(processor,F_Z, (val == 0));
+	Z80free_valFlag(processor,F_N, isDec);
+
+	Z80free_adjustFlags(processor, val);
+
+	return val;
+}
+
+
+word Z80free_doIncDec16 (Z80FREE *processor, word val, int isDec) {
+
+	if (isDec) {
+		val--;
+	} else {
+		val++;
+	}
+
+	return val;
+}
+
+
+byte Z80free_doRLC (Z80FREE *processor, int adjFlags, byte val) {
+
+	Z80free_valFlag(processor,F_C, (val & 0x80) != 0);
+	val <<= 1;
+	val |= (byte)Z80free_getFlag(processor,F_C);
+
+	Z80free_adjustFlags(processor, val);
+	Z80free_resFlag(processor,F_H | F_N);
+
+	if (adjFlags)
+		Z80free_adjustFlagSZP(processor, val);
+
+	return val;
+}
+
+
+byte Z80free_doRL (Z80FREE *processor, int adjFlags, byte val) {
+
+	int CY = Z80free_getFlag(processor,F_C);
+	Z80free_valFlag(processor,F_C, (val & 0x80) != 0);
+	val <<= 1;
+	val |= (byte)CY;
+
+	Z80free_adjustFlags(processor, val);
+	Z80free_resFlag(processor,F_H | F_N);
+
+	if (adjFlags)
+		Z80free_adjustFlagSZP(processor, val);
+
+	return val;
+}
+
+
+byte Z80free_doRRC (Z80FREE *processor, int adjFlags, byte val) {
+
+	Z80free_valFlag(processor,F_C, (val & 0x01) != 0);
+	val >>= 1;
+	val |= ((byte)Z80free_getFlag(processor,F_C) << 7);
+
+	Z80free_adjustFlags(processor, val);
+	Z80free_resFlag(processor,F_H | F_N);
+
+	if (adjFlags)
+		Z80free_adjustFlagSZP(processor, val);
+
+	return val;
+}
+
+
+byte Z80free_doRR (Z80FREE *processor, int adjFlags, byte val) {
+
+	int CY = Z80free_getFlag(processor,F_C);
+	Z80free_valFlag(processor,F_C, (val & 0x01));
+	val >>= 1;
+	val |= (CY << 7);
+
+	Z80free_adjustFlags(processor, val);
+	Z80free_resFlag(processor,F_H | F_N);
+
+	if (adjFlags)
+		Z80free_adjustFlagSZP(processor, val);
+
+	return val;
+}
+
+
+byte Z80free_doSL (Z80FREE *processor, int isArith, byte val) {
+
+	Z80free_valFlag(processor,F_C, (val & 0x80) != 0);
+	val <<= 1;
+
+	if (isArith)
+		val |= 1;
+
+	Z80free_adjustFlags(processor, val);
+	Z80free_resFlag(processor,F_H | F_N);
+	Z80free_adjustFlagSZP(processor, val);
+
+	return val;
+}
+
+
+byte Z80free_doSR (Z80FREE *processor, int isArith, byte val) {
+
+	static int b;
+
+	b = (val & 0x80);
+
+	Z80free_valFlag(processor,F_C, (val & 0x01) != 0);
+	val >>= 1;
+
+	if (isArith)
+		val |= (byte)b;
+
+	Z80free_adjustFlags(processor, val);
+	Z80free_resFlag(processor,F_H | F_N);
+	Z80free_adjustFlagSZP(processor, val);
+
+	return val;
+}
+
+void Z80free_doRLD(Z80FREE *processor) {
+
+	static byte tmp,tmp2;
+
+	tmp=processor->Rm.br.A;
+	tmp2=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+	processor->Rm.br.A&=0xF0;
+	processor->Rm.br.A|=(0x0F&(tmp2>>4));
+	Z80free_Wr_Internal(processor,processor->Rm.wr.HL,((tmp2<<4)&0xF0)|(tmp&0x0F));
+
+	Z80free_resFlag(processor,F_H | F_N);
+	Z80free_adjustFlagSZP(processor, processor->Rm.br.A);
+
+}
+
+void Z80free_doRRD(Z80FREE *processor) {
+
+	static byte tmp,tmp2;
+
+	tmp=processor->Rm.br.A;
+	tmp2=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+	processor->Rm.br.A&=0xF0;
+	processor->Rm.br.A|=(0x0F&tmp2);
+	Z80free_Wr_Internal(processor,processor->Rm.wr.HL,((tmp2>>4)&0x0F)|((tmp<<4)&0xF0));
+
+	Z80free_resFlag(processor,F_H | F_N);
+	Z80free_adjustFlagSZP(processor, processor->Rm.br.A);
+
+}
+
+void Z80free_doPush (Z80FREE *processor, word val) {
+
+	processor->Rm.wr.SP--;
+	Z80free_Wr_Internal(processor,processor->Rm.wr.SP, (byte)((val>>8) & 0xFF));
+	processor->Rm.wr.SP--;
+	Z80free_Wr_Internal(processor,processor->Rm.wr.SP, (byte)(val & 0xFF));
+}
+
+
+word Z80free_doPop (Z80FREE *processor) {
+
+	static word val;
+
+	val = Z80free_read16(processor, processor->Rm.wr.SP);
+	processor->Rm.wr.SP+=2;
+
+	return val;
+}
+
+
+/* The DAA opcode
+ * According to the value in A and the flags set, add a value to A
+ *
+ * Flags set   Byte (0..9)(0..9)
+ * --------------------------------------------
+ * (None)   + &00
+ * Carry:+ &60
+ * Subtract:+ &00
+ * Subtract+Carry:+ &A0
+ * Half-carry:+ &06
+ * Half-carry+Carry:+ &66
+ * Half-carry+Subtract:+ &FA
+ * Half-carry+Subtract+Carry:+ &9A
+ *
+ * Flags set   Byte (0..9)(A..F)
+ * --------------------------------------------
+ * (None)   + &06
+ * Carry:+ &66
+ * Subtract:+ &00
+ * Subtract+Carry:+ &a0
+ * Half-carry:+ &06
+ * Half-carry+Carry:+ &66
+ * Half-carry+Subtract:+ &fa
+ * Half-carry+Subtract+Carry:+ &9A
+ *
+ * Flags set   Byte (A..F)(0..9)
+ * --------------------------------------------
+ * (None)   + &60
+ * Carry:+ &60
+ * Subtract:+ &00
+ * Subtract+Carry:+ &A0
+ * Half-carry:+ &66
+ * Half-carry+Carry:+ &66
+ * Half-carry+Subtract:+ &fa
+ * Half-carry+Subtract+Carry:+ &9A
+ *
+ * Flags set   Byte (A..F)(A..F)
+ * --------------------------------------------
+ * (None)   + &66
+ * Carry:+ &66
+ * Subtract:+ &00
+ * Subtract+Carry:+ &a0
+ * Half-carry:+ &66
+ * Half-carry+Carry:+ &66
+ * Half-carry+Subtract:+ &fa
+ * Half-carry+Subtract+Carry:+ &9A
+ */
+
+static int Z80free_DAA_BYTETYPE1[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 };
+static int Z80free_DAA_BYTETYPE2[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2 };
+
+static byte Z80free_DAA_ADJUSTMENT[4][6] = {
+	{0x00,0x06,0x00,0x66,0x60,0x66},
+	{0x06,0x06,0x06,0x66,0x66,0x66},
+	{0x60,0x66,0x60,0x66,0x60,0x66},
+	{0x66,0x66,0x66,0x66,0x66,0x66} };
+
+void Z80free_doDAA (Z80FREE *processor) {
+
+	byte oldval;
+	int byteType;
+	int flagMask = 0;
+
+	/* (0..8)(0..9) = 0 */
+	/* (0..8)(A..F) = 1 */
+	/*  (9)  (0..9) = 2 */
+	/*  (9)  (A..F) = 3 */
+	/* (A..F)(0..9) = 4 */
+	/* (A..F)(A..F) = 5 */
+	byteType = Z80free_DAA_BYTETYPE1[(processor->Rm.br.A&0x0F)] | ((Z80free_DAA_BYTETYPE2[(processor->Rm.br.A >> 4)&0x0F]) << 1);
+	oldval=(processor->Rm.br.A&0x0F);
+
+	if (Z80free_getFlag(processor,F_C))
+		flagMask |= 2;
+	if (Z80free_getFlag(processor,F_H))
+		flagMask |= 1;
+
+	if (processor->Rm.br.F&F_N) {
+		processor->Rm.br.A -= Z80free_DAA_ADJUSTMENT[flagMask][byteType];
+	} else {
+		processor->Rm.br.A += Z80free_DAA_ADJUSTMENT[flagMask][byteType];
+	}
+	if ((byteType<3)&&((processor->Rm.br.F&F_C)==0)) {
+		Z80free_resFlag(processor,F_C);
+	} else {
+		Z80free_setFlag(processor,F_C);
+	}
+
+	if ((processor->Rm.br.F&F_N)==0) {
+		if (oldval>9) {
+			Z80free_setFlag(processor,F_H);
+		} else {
+			Z80free_resFlag(processor,F_H);
+		}
+	} else {
+		if (processor->Rm.br.F&F_H) {
+			if (oldval>5) {
+				Z80free_resFlag(processor,F_H);
+			} else {
+				Z80free_setFlag(processor,F_H);
+			}
+		}
+	}
+
+	processor->Rm.br.F&=0x57;
+	processor->Rm.br.F|=(processor->Rm.br.A&0xA4);
+	if (processor->Rm.br.A) {
+		Z80free_resFlag(processor,F_Z);
+	} else {
+		Z80free_setFlag(processor,F_Z);
+	}
+	Z80free_valFlag(processor,F_PV, Z80free_parityBit[processor->Rm.br.A]);
+}
+
+void Z80free_jump_relative(Z80FREE *processor,byte relvar) {
+
+	static word rel2;
+
+	rel2=(word)relvar;
+	if (relvar&0x080) {
+			rel2|=0xFF00;
+	}
+	processor->PC+=rel2;
+}
+
+word Z80free_addr_relative(Z80FREE *processor,word address) {
+
+	static word rel2;
+
+	if (processor->IAddr_done) {
+		return (processor->IAddr);
+	}
+	processor->IAddr_done=1;
+	rel2 = (word)Z80free_read_param_8(processor);
+	processor->subtstates += 5; // 5 tstates are needed: 3 to read the d value and 5 internal
+	if (rel2&0x080) {
+			rel2|=0xFF00;
+	}
+	processor->IAddr=address+rel2;
+	return (address+rel2);
+}
+
+word Z80free_addr_relativeXDCB(Z80FREE *processor,word address,byte d1) {
+
+	static word rel2;
+
+	rel2=(word)d1;
+	if (rel2&0x080) {
+			rel2|=0xFF00;
+	}
+	processor->IAddr=address+rel2;
+	return (address+rel2);
+}
+
+void Z80free_write16 (Z80FREE *processor, word addr,word val) {
+
+	Z80free_Wr_Internal(processor,addr, (byte)(val & 0xFF));
+	val >>= 8;
+	addr++;
+	Z80free_Wr_Internal(processor,addr, (byte)(val & 0xFF));
+}
+
+word Z80free_read16 (Z80FREE *processor, word addr) {
+
+	static word v1;
+	v1=((word)Z80free_Rd_Internal(processor,addr))&0x00FF;
+	addr++;
+	return (v1 + ((((word)Z80free_Rd_Internal(processor,addr)) << 8)&0xFF00));
+}
+
+byte Z80free_read_param_8(Z80FREE *processor) {
+
+	byte data = Z80free_Rd_Internal(processor,processor->PC++);
+	return(data);
+
+}
+
+word Z80free_read_param_16(Z80FREE *processor) {
+
+	static word value;
+	value = Z80free_read16(processor, processor->PC);
+	processor->PC+=2;
+	return (value);
+}
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free_codes.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codes.c
--- fuse-1.6.0/peripherals/disk/z80free/Z80free_codes.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codes.c	2023-08-07 09:56:42.531706621 +0200
@@ -0,0 +1,1242 @@
+/*
+ * Copyright (C) 2008-2009 Sergio Costas (Raster Software Vigo)
+ * This file is part of Z80Free
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ */
+
+#include "Z80free.h"
+
+int Z80free_codes (Z80FREE *processor,byte opcode) {
+	static byte tmp1;
+	static word tmp2;
+
+	switch(opcode) {
+	case 0: // NOP
+		return (4);
+	break;
+	case 1: // LD BC,nn
+		processor->Rm.wr.BC=Z80free_read_param_16(processor);
+		return (10);
+	break;
+	case 2: // LD (BC),A
+		Z80free_Wr_Internal(processor,processor->Rm.wr.BC,processor->Rm.br.A);
+		return (7);
+	break;
+	case 3: // INC BC
+		processor->Rm.wr.BC=Z80free_doIncDec16(processor,processor->Rm.wr.BC,0);
+		return (6);
+	break;
+	case 4: // INC B
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,0);
+		return (4);
+	break;
+	case 5: // DEC B
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		return (4);
+	break;
+	case 6: // LD B,n
+		processor->Rm.br.B=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 7: // RLCA
+		processor->Rm.br.A=Z80free_doRLC(processor,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 8: // EX AF,AF'
+		tmp2=processor->Rm.wr.AF;
+		processor->Rm.wr.AF=processor->Ra.wr.AF;
+		processor->Ra.wr.AF=tmp2;
+		return (4);
+	break;
+	case 9: // ADD HL,BC
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.BC,0,0);
+		return (11);
+	break;
+	case 10: // LD A,(BC)
+		processor->Rm.br.A=Z80free_Rd_Internal(processor,processor->Rm.wr.BC);
+		return (7);
+	break;
+	case 11: // DEC BC
+		processor->Rm.wr.BC=Z80free_doIncDec16(processor,processor->Rm.wr.BC,1);
+		return (6);
+	break;
+	case 12: // INC C
+		processor->Rm.br.C=Z80free_doIncDec(processor,processor->Rm.br.C,0);
+		return (4);
+	break;
+	case 13: // DEC C
+		processor->Rm.br.C=Z80free_doIncDec(processor,processor->Rm.br.C,1);
+		return (4);
+	break;
+	case 14: // LD C,n
+		processor->Rm.br.C=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 15: // RRCA
+		processor->Rm.br.A=Z80free_doRRC(processor,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 16: // DJNZ n
+		tmp1=Z80free_read_param_8(processor);
+		processor->Rm.br.B--;
+		if (processor->Rm.br.B) {
+			Z80free_jump_relative(processor,tmp1);
+			return (13);
+		} else {
+			return (8);
+		}
+	break;
+	case 17: // LD DE,nn
+		processor->Rm.wr.DE=Z80free_read_param_16(processor);
+		return (10);
+	break;
+	case 18: // LD (DE),A
+		Z80free_Wr_Internal(processor,processor->Rm.wr.DE,processor->Rm.br.A);
+		return (7);
+	break;
+	case 19: // INC DE
+		processor->Rm.wr.DE=Z80free_doIncDec16(processor,processor->Rm.wr.DE,0);
+		return (6);
+	break;
+	case 20: // INC D
+		processor->Rm.br.D=Z80free_doIncDec(processor,processor->Rm.br.D,0);
+		return (4);
+	break;
+	case 21: // DEC D
+		processor->Rm.br.D=Z80free_doIncDec(processor,processor->Rm.br.D,1);
+		return (4);
+	break;
+	case 22: // LD D,n
+		processor->Rm.br.D=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 23: // RLA
+		processor->Rm.br.A=Z80free_doRL(processor,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 24: // JR n
+		tmp1=Z80free_read_param_8(processor);
+		Z80free_jump_relative(processor,tmp1);
+		return (12);
+	break;
+	case 25: // ADD HL,DE
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.DE,0,0);
+		return (11);
+	break;
+	case 26: // LD A,(DE)
+		processor->Rm.br.A=Z80free_Rd_Internal(processor,processor->Rm.wr.DE);
+		return (7);
+	break;
+	case 27: // DEC DE
+		processor->Rm.wr.DE=Z80free_doIncDec16(processor,processor->Rm.wr.DE,1);
+		return (6);
+	break;
+	case 28: // INC E
+		processor->Rm.br.E=Z80free_doIncDec(processor,processor->Rm.br.E,0);
+		return (4);
+	break;
+	case 29: // DEC E
+		processor->Rm.br.E=Z80free_doIncDec(processor,processor->Rm.br.E,1);
+		return (4);
+	break;
+	case 30: // LD E,n
+		processor->Rm.br.E=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 31: // RRA
+		processor->Rm.br.A=Z80free_doRR(processor,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 32: // JR NZ,n
+		tmp1=Z80free_read_param_8(processor);
+		if (0==(F_Z&processor->Rm.br.F)) {
+			Z80free_jump_relative(processor,tmp1);
+			return (12);
+		} else {
+			return (7);
+		}
+	break;
+	case 33: // LD HL,nn
+		processor->Rm.wr.HL=Z80free_read_param_16(processor);
+		return (10);
+	break;
+	case 34: // LD (nn),HL
+		Z80free_write16(processor, Z80free_read_param_16(processor),processor->Rm.wr.HL);
+		return (16);
+	break;
+	case 35: // INC HL
+		processor->Rm.wr.HL=Z80free_doIncDec16(processor,processor->Rm.wr.HL,0);
+		return (6);
+	break;
+	case 36: // INC H
+		processor->Rm.br.H=Z80free_doIncDec(processor,processor->Rm.br.H,0);
+		return (4);
+	break;
+	case 37: // DEC H
+		processor->Rm.br.H=Z80free_doIncDec(processor,processor->Rm.br.H,1);
+		return (4);
+	break;
+	case 38: // LD H,n
+		processor->Rm.br.H=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 39: // DAA
+		Z80free_doDAA(processor);
+		return (4);
+	break;
+	case 40: // JR Z,n
+		tmp1=Z80free_read_param_8(processor);
+		if (F_Z&processor->Rm.br.F) {
+			Z80free_jump_relative(processor,tmp1);
+			return (12);
+		} else {
+			return (7);
+		}
+	break;
+	case 41: // ADD HL,HL
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.HL,0,0);
+		return (11);
+	break;
+	case 42: // LD HL,(nn)
+		processor->Rm.wr.HL=Z80free_read16(processor, Z80free_read_param_16(processor));
+		return (16);
+	break;
+	case 43: // DEC HL
+		processor->Rm.wr.HL=Z80free_doIncDec16(processor,processor->Rm.wr.HL,1);
+		return (6);
+	break;
+	case 44: // INC L
+		processor->Rm.br.L=Z80free_doIncDec(processor,processor->Rm.br.L,0);
+		return (4);
+	break;
+	case 45: // DEC L
+		processor->Rm.br.L=Z80free_doIncDec(processor,processor->Rm.br.L,1);
+		return (4);
+	break;
+	case 46: // LD L,n
+		processor->Rm.br.L=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 47: // CPL
+		processor->Rm.br.A=255-processor->Rm.br.A;
+		Z80free_adjustFlags(processor,processor->Rm.br.A);
+		Z80free_setFlag(processor,F_H);
+		Z80free_setFlag(processor,F_N);
+		return (4);
+	break;
+	case 48: // JR NC,n
+		tmp1=Z80free_read_param_8(processor);
+		if (0==(F_C&processor->Rm.br.F)) {
+			Z80free_jump_relative(processor,tmp1);
+			return (12);
+		} else {
+			return (7);
+		}
+	break;
+	case 49: // LD SP,nn
+		processor->Rm.wr.SP=Z80free_read_param_16(processor);
+		return (10);
+	break;
+	case 50: // LD (nn),A
+		Z80free_Wr_Internal(processor,Z80free_read_param_16(processor),processor->Rm.br.A);
+		return (13);
+	break;
+	case 51: // INC SP
+		processor->Rm.wr.SP=Z80free_doIncDec16(processor,processor->Rm.wr.SP,0);
+		return (6);
+	break;
+	case 52: // INC b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doIncDec(processor,Z80free_Rd_Internal(processor,processor->Rm.wr.HL),0));
+		return (11);
+	break;
+	case 53: // DEC b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doIncDec(processor,Z80free_Rd_Internal(processor,processor->Rm.wr.HL),1));
+		return (11);
+	break;
+	case 54: // LD (HL),n
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_read_param_8(processor));
+		return (10);
+	break;
+	case 55: // SCF
+		Z80free_setFlag(processor,F_C);
+		Z80free_resFlag(processor,F_H);
+		Z80free_resFlag(processor,F_N);
+		Z80free_adjustFlags(processor,processor->Rm.br.A);
+		return (4);
+	break;
+	case 56: // JR CF,n
+		tmp1=Z80free_read_param_8(processor);
+		if (F_C&processor->Rm.br.F) {
+			Z80free_jump_relative(processor,tmp1);
+			return (12);
+		} else {
+			return (7);
+		}
+	break;
+	case 57: // ADD HL,SP
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.SP,0,0);
+		return (11);
+	break;
+	case 58: // LD A,(nn)
+		processor->Rm.br.A=Z80free_Rd_Internal(processor,Z80free_read_param_16(processor));
+		return (13);
+	break;
+	case 59: // DEC SP
+		processor->Rm.wr.SP=Z80free_doIncDec16(processor,processor->Rm.wr.SP,1);
+		return (6);
+	break;
+	case 60: // INC A
+		processor->Rm.br.A=Z80free_doIncDec(processor,processor->Rm.br.A,0);
+		return (4);
+	break;
+	case 61: // DEC A
+		processor->Rm.br.A=Z80free_doIncDec(processor,processor->Rm.br.A,1);
+		return (4);
+	break;
+	case 62: // LD A,n
+		processor->Rm.br.A=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 63: // CCF
+		Z80free_valFlag(processor,F_C,(~processor->Rm.br.F)&F_C);
+		Z80free_resFlag(processor,F_N);
+		Z80free_adjustFlags(processor,processor->Rm.br.A);
+		return (4);
+	break;
+	case 64: // LD B,B
+		processor->Rm.br.B=processor->Rm.br.B;
+		return (4);
+	break;
+	case 65: // LD B,C
+		processor->Rm.br.B=processor->Rm.br.C;
+		return (4);
+	break;
+	case 66: // LD B,D
+		processor->Rm.br.B=processor->Rm.br.D;
+		return (4);
+	break;
+	case 67: // LD B,E
+		processor->Rm.br.B=processor->Rm.br.E;
+		return (4);
+	break;
+	case 68: // LD B,H
+		processor->Rm.br.B=processor->Rm.br.H;
+		return (4);
+	break;
+	case 69: // LD B,L
+		processor->Rm.br.B=processor->Rm.br.L;
+		return (4);
+	break;
+	case 70: // LD B,(HL)
+		processor->Rm.br.B=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		return (7);
+	break;
+	case 71: // LD B,A
+		processor->Rm.br.B=processor->Rm.br.A;
+		return (4);
+	break;
+	case 72: // LD C,B
+		processor->Rm.br.C=processor->Rm.br.B;
+		return (4);
+	break;
+	case 73: // LD C,C
+		processor->Rm.br.C=processor->Rm.br.C;
+		return (4);
+	break;
+	case 74: // LD C,D
+		processor->Rm.br.C=processor->Rm.br.D;
+		return (4);
+	break;
+	case 75: // LD C,E
+		processor->Rm.br.C=processor->Rm.br.E;
+		return (4);
+	break;
+	case 76: // LD C,H
+		processor->Rm.br.C=processor->Rm.br.H;
+		return (4);
+	break;
+	case 77: // LD C,L
+		processor->Rm.br.C=processor->Rm.br.L;
+		return (4);
+	break;
+	case 78: // LD C,(HL)
+		processor->Rm.br.C=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		return (7);
+	break;
+	case 79: // LD C,A
+		processor->Rm.br.C=processor->Rm.br.A;
+		return (4);
+	break;
+	case 80: // LD D,B
+		processor->Rm.br.D=processor->Rm.br.B;
+		return (4);
+	break;
+	case 81: // LD D,C
+		processor->Rm.br.D=processor->Rm.br.C;
+		return (4);
+	break;
+	case 82: // LD D,D
+		processor->Rm.br.D=processor->Rm.br.D;
+		return (4);
+	break;
+	case 83: // LD D,E
+		processor->Rm.br.D=processor->Rm.br.E;
+		return (4);
+	break;
+	case 84: // LD D,H
+		processor->Rm.br.D=processor->Rm.br.H;
+		return (4);
+	break;
+	case 85: // LD D,L
+		processor->Rm.br.D=processor->Rm.br.L;
+		return (4);
+	break;
+	case 86: // LD D,(HL)
+		processor->Rm.br.D=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		return (7);
+	break;
+	case 87: // LD D,A
+		processor->Rm.br.D=processor->Rm.br.A;
+		return (4);
+	break;
+	case 88: // LD E,B
+		processor->Rm.br.E=processor->Rm.br.B;
+		return (4);
+	break;
+	case 89: // LD E,C
+		processor->Rm.br.E=processor->Rm.br.C;
+		return (4);
+	break;
+	case 90: // LD E,D
+		processor->Rm.br.E=processor->Rm.br.D;
+		return (4);
+	break;
+	case 91: // LD E,E
+		processor->Rm.br.E=processor->Rm.br.E;
+		return (4);
+	break;
+	case 92: // LD E,H
+		processor->Rm.br.E=processor->Rm.br.H;
+		return (4);
+	break;
+	case 93: // LD E,L
+		processor->Rm.br.E=processor->Rm.br.L;
+		return (4);
+	break;
+	case 94: // LD E,(HL)
+		processor->Rm.br.E=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		return (7);
+	break;
+	case 95: // LD E,A
+		processor->Rm.br.E=processor->Rm.br.A;
+		return (4);
+	break;
+	case 96: // LD H,B
+		processor->Rm.br.H=processor->Rm.br.B;
+		return (4);
+	break;
+	case 97: // LD H,C
+		processor->Rm.br.H=processor->Rm.br.C;
+		return (4);
+	break;
+	case 98: // LD H,D
+		processor->Rm.br.H=processor->Rm.br.D;
+		return (4);
+	break;
+	case 99: // LD H,E
+		processor->Rm.br.H=processor->Rm.br.E;
+		return (4);
+	break;
+	case 100: // LD H,H
+		processor->Rm.br.H=processor->Rm.br.H;
+		return (4);
+	break;
+	case 101: // LD H,L
+		processor->Rm.br.H=processor->Rm.br.L;
+		return (4);
+	break;
+	case 102: // LD H,(HL)
+		processor->Rm.br.H=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		return (7);
+	break;
+	case 103: // LD H,A
+		processor->Rm.br.H=processor->Rm.br.A;
+		return (4);
+	break;
+	case 104: // LD L,B
+		processor->Rm.br.L=processor->Rm.br.B;
+		return (4);
+	break;
+	case 105: // LD L,C
+		processor->Rm.br.L=processor->Rm.br.C;
+		return (4);
+	break;
+	case 106: // LD L,D
+		processor->Rm.br.L=processor->Rm.br.D;
+		return (4);
+	break;
+	case 107: // LD L,E
+		processor->Rm.br.L=processor->Rm.br.E;
+		return (4);
+	break;
+	case 108: // LD L,H
+		processor->Rm.br.L=processor->Rm.br.H;
+		return (4);
+	break;
+	case 109: // LD L,L
+		processor->Rm.br.L=processor->Rm.br.L;
+		return (4);
+	break;
+	case 110: // LD L,(HL)
+		processor->Rm.br.L=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		return (7);
+	break;
+	case 111: // LD L,A
+		processor->Rm.br.L=processor->Rm.br.A;
+		return (4);
+	break;
+	case 112: // LD (HL),B
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,processor->Rm.br.B);
+		return (7);
+	break;
+	case 113: // LD (HL),C
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,processor->Rm.br.C);
+		return (7);
+	break;
+	case 114: // LD (HL),D
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,processor->Rm.br.D);
+		return (7);
+	break;
+	case 115: // LD (HL),E
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,processor->Rm.br.E);
+		return (7);
+	break;
+	case 116: // LD (HL),H
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,processor->Rm.br.H);
+		return (7);
+	break;
+	case 117: // LD (HL),L
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,processor->Rm.br.L);
+		return (7);
+	break;
+	case 118: // HALT
+		processor->PC--;
+		processor->HALT=1;
+		return (4);
+	break;
+	case 119: // LD (HL),A
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,processor->Rm.br.A);
+		return (7);
+	break;
+	case 120: // LD A,B
+		processor->Rm.br.A=processor->Rm.br.B;
+		return (4);
+	break;
+	case 121: // LD A,C
+		processor->Rm.br.A=processor->Rm.br.C;
+		return (4);
+	break;
+	case 122: // LD A,D
+		processor->Rm.br.A=processor->Rm.br.D;
+		return (4);
+	break;
+	case 123: // LD A,E
+		processor->Rm.br.A=processor->Rm.br.E;
+		return (4);
+	break;
+	case 124: // LD A,H
+		processor->Rm.br.A=processor->Rm.br.H;
+		return (4);
+	break;
+	case 125: // LD A,L
+		processor->Rm.br.A=processor->Rm.br.L;
+		return (4);
+	break;
+	case 126: // LD A,(HL)
+		processor->Rm.br.A=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		return (7);
+	break;
+	case 127: // LD A,A
+		processor->Rm.br.A=processor->Rm.br.A;
+		return (4);
+	break;
+	case 128: // ADD A,B
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.B,0,0);
+		return (4);
+	break;
+	case 129: // ADD A,C
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.C,0,0);
+		return (4);
+	break;
+	case 130: // ADD A,D
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.D,0,0);
+		return (4);
+	break;
+	case 131: // ADD A,E
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.E,0,0);
+		return (4);
+	break;
+	case 132: // ADD A,H
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.H,0,0);
+		return (4);
+	break;
+	case 133: // ADD A,L
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.L,0,0);
+		return (4);
+	break;
+	case 134: // ADD A,(HL)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,processor->Rm.wr.HL),0,0);
+		return (7);
+	break;
+	case 135: // ADD A,A
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.A,0,0);
+		return (4);
+	break;
+	case 136: // ADC A,B
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.B,1,0);
+		return (4);
+	break;
+	case 137: // ADC A,C
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.C,1,0);
+		return (4);
+	break;
+	case 138: // ADC A,D
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.D,1,0);
+		return (4);
+	break;
+	case 139: // ADC A,E
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.E,1,0);
+		return (4);
+	break;
+	case 140: // ADC A,H
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.H,1,0);
+		return (4);
+	break;
+	case 141: // ADC A,L
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.L,1,0);
+		return (4);
+	break;
+	case 142: // ADC A,(HL)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,processor->Rm.wr.HL),1,0);
+		return (7);
+	break;
+	case 143: // ADC A,A
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.A,1,0);
+		return (4);
+	break;
+	case 144: // SUB B
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.B,0,1);
+		return (4);
+	break;
+	case 145: // SUB C
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.C,0,1);
+		return (4);
+	break;
+	case 146: // SUB D
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.D,0,1);
+		return (4);
+	break;
+	case 147: // SUB E
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.E,0,1);
+		return (4);
+	break;
+	case 148: // SUB H
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.H,0,1);
+		return (4);
+	break;
+	case 149: // SUB L
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.L,0,1);
+		return (4);
+	break;
+	case 150: // SUB b(HL)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,processor->Rm.wr.HL),0,1);
+		return (7);
+	break;
+	case 151: // SUB A
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 152: // SBC A,B
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.B,1,1);
+		return (4);
+	break;
+	case 153: // SBC A,C
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.C,1,1);
+		return (4);
+	break;
+	case 154: // SBC A,D
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.D,1,1);
+		return (4);
+	break;
+	case 155: // SBC A,E
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.E,1,1);
+		return (4);
+	break;
+	case 156: // SBC A,H
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.H,1,1);
+		return (4);
+	break;
+	case 157: // SBC A,L
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.L,1,1);
+		return (4);
+	break;
+	case 158: // SBC A,(HL)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,processor->Rm.wr.HL),1,1);
+		return (7);
+	break;
+	case 159: // SBC A,A
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.A,1,1);
+		return (4);
+	break;
+	case 160: // AND B
+		Z80free_doAND(processor,processor->Rm.br.B);
+		return (4);
+	break;
+	case 161: // AND C
+		Z80free_doAND(processor,processor->Rm.br.C);
+		return (4);
+	break;
+	case 162: // AND D
+		Z80free_doAND(processor,processor->Rm.br.D);
+		return (4);
+	break;
+	case 163: // AND E
+		Z80free_doAND(processor,processor->Rm.br.E);
+		return (4);
+	break;
+	case 164: // AND H
+		Z80free_doAND(processor,processor->Rm.br.H);
+		return (4);
+	break;
+	case 165: // AND L
+		Z80free_doAND(processor,processor->Rm.br.L);
+		return (4);
+	break;
+	case 166: // AND b(HL)
+		Z80free_doAND(processor,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (7);
+	break;
+	case 167: // AND A
+		Z80free_doAND(processor,processor->Rm.br.A);
+		return (4);
+	break;
+	case 168: // XOR B
+		Z80free_doXOR(processor,processor->Rm.br.B);
+		return (4);
+	break;
+	case 169: // XOR C
+		Z80free_doXOR(processor,processor->Rm.br.C);
+		return (4);
+	break;
+	case 170: // XOR D
+		Z80free_doXOR(processor,processor->Rm.br.D);
+		return (4);
+	break;
+	case 171: // XOR E
+		Z80free_doXOR(processor,processor->Rm.br.E);
+		return (4);
+	break;
+	case 172: // XOR H
+		Z80free_doXOR(processor,processor->Rm.br.H);
+		return (4);
+	break;
+	case 173: // XOR L
+		Z80free_doXOR(processor,processor->Rm.br.L);
+		return (4);
+	break;
+	case 174: // XOR b(HL)
+		Z80free_doXOR(processor,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (7);
+	break;
+	case 175: // XOR A
+		Z80free_doXOR(processor,processor->Rm.br.A);
+		return (4);
+	break;
+	case 176: // OR B
+		Z80free_doOR(processor,processor->Rm.br.B);
+		return (4);
+	break;
+	case 177: // OR C
+		Z80free_doOR(processor,processor->Rm.br.C);
+		return (4);
+	break;
+	case 178: // OR D
+		Z80free_doOR(processor,processor->Rm.br.D);
+		return (4);
+	break;
+	case 179: // OR E
+		Z80free_doOR(processor,processor->Rm.br.E);
+		return (4);
+	break;
+	case 180: // OR H
+		Z80free_doOR(processor,processor->Rm.br.H);
+		return (4);
+	break;
+	case 181: // OR L
+		Z80free_doOR(processor,processor->Rm.br.L);
+		return (4);
+	break;
+	case 182: // OR b(HL)
+		Z80free_doOR(processor,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (7);
+	break;
+	case 183: // OR A
+		Z80free_doOR(processor,processor->Rm.br.A);
+		return (4);
+	break;
+	case 184: // CP B
+		tmp1=processor->Rm.br.B;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 185: // CP C
+		tmp1=processor->Rm.br.C;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 186: // CP D
+		tmp1=processor->Rm.br.D;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 187: // CP E
+		tmp1=processor->Rm.br.E;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 188: // CP H
+		tmp1=processor->Rm.br.H;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 189: // CP L
+		tmp1=processor->Rm.br.L;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 190: // CP b(HL)
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (7);
+	break;
+	case 191: // CP A
+		tmp1=processor->Rm.br.A;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 192: // RET NZ
+		if (0==(F_Z&processor->Rm.br.F)) {
+			processor->PC=Z80free_doPop(processor);
+			return (11);
+		} else {
+			return (5);
+		}
+	break;
+	case 193: // POP BC
+		processor->Rm.wr.BC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 194: // JP NZ,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (0==(F_Z&processor->Rm.br.F)) {
+			processor->PC=tmp2;
+			return (10);
+		} else {
+			return (10);
+		}
+	break;
+	case 195: // JP nn
+		tmp2=Z80free_read_param_16(processor);
+		processor->PC=tmp2;
+		return (10);
+	break;
+	case 196: // CALL NZ,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (0==(F_Z&processor->Rm.br.F)) {
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=tmp2;
+			return (17);
+		} else {
+			return (10);
+		}
+	break;
+	case 197: // PUSH BC
+		Z80free_doPush(processor,processor->Rm.wr.BC);
+		return (11);
+	break;
+	case 198: // ADD A,n
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_read_param_8(processor),0,0);
+		return (7);
+	break;
+	case 199: // RST 0H
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=0;
+		return (11);
+	break;
+	case 200: // RET Z
+		if (F_Z&processor->Rm.br.F) {
+			processor->PC=Z80free_doPop(processor);
+			return (11);
+		} else {
+			return (5);
+		}
+	break;
+	case 201: // RET
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 202: // JP Z,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (F_Z&processor->Rm.br.F) {
+			processor->PC=tmp2;
+			return (10);
+		} else {
+			return (10);
+		}
+	break;
+	case 204: // CALL Z,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (F_Z&processor->Rm.br.F) {
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=tmp2;
+			return (17);
+		} else {
+			return (10);
+		}
+	break;
+	case 205: // CALL nn
+		tmp2=Z80free_read_param_16(processor);
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=tmp2;
+		return (17);
+	break;
+	case 206: // ADC A,n
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_read_param_8(processor),1,0);
+		return (7);
+	break;
+	case 207: // RST 8H
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=8;
+		return (11);
+	break;
+	case 208: // RET NC
+		if (0==(F_C&processor->Rm.br.F)) {
+			processor->PC=Z80free_doPop(processor);
+			return (11);
+		} else {
+			return (5);
+		}
+	break;
+	case 209: // POP DE
+		processor->Rm.wr.DE=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 210: // JP NC,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (0==(F_C&processor->Rm.br.F)) {
+			processor->PC=tmp2;
+			return (10);
+		} else {
+			return (10);
+		}
+	break;
+	case 211: // OUT n,A
+		tmp1=processor->Rm.br.A;
+		tmp2=((word)tmp1)<<8;
+		Z80free_Out_Internal(processor,tmp2+((word)Z80free_read_param_8(processor)),tmp1);
+		return (11);
+	break;
+	case 212: // CALL NC,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (0==(F_C&processor->Rm.br.F)) {
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=tmp2;
+			return (17);
+		} else {
+			return (10);
+		}
+	break;
+	case 213: // PUSH DE
+		Z80free_doPush(processor,processor->Rm.wr.DE);
+		return (11);
+	break;
+	case 214: // SUB n
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_read_param_8(processor),0,1);
+		return (7);
+	break;
+	case 215: // RST 10H
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=16;
+		return (11);
+	break;
+	case 216: // RET CF
+		if (F_C&processor->Rm.br.F) {
+			processor->PC=Z80free_doPop(processor);
+			return (11);
+		} else {
+			return (5);
+		}
+	break;
+	case 217: // EXX
+		tmp2=processor->Rm.wr.BC;
+		processor->Rm.wr.BC=processor->Ra.wr.BC;
+		processor->Ra.wr.BC=tmp2;
+		tmp2=processor->Rm.wr.DE;
+		processor->Rm.wr.DE=processor->Ra.wr.DE;
+		processor->Ra.wr.DE=tmp2;
+		tmp2=processor->Rm.wr.HL;
+		processor->Rm.wr.HL=processor->Ra.wr.HL;
+		processor->Ra.wr.HL=tmp2;
+		return (4);
+	break;
+	case 218: // JP CF,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (F_C&processor->Rm.br.F) {
+			processor->PC=tmp2;
+			return (10);
+		} else {
+			return (10);
+		}
+	break;
+	case 219: // IN A,n
+		tmp2=((word)processor->Rm.br.A)<<8;
+		processor->Rm.br.A=Z80free_In_Internal(processor,tmp2+((word)Z80free_read_param_8(processor)));
+		return (11);
+	break;
+	case 220: // CALL CF,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (F_C&processor->Rm.br.F) {
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=tmp2;
+			return (17);
+		} else {
+			return (10);
+		}
+	break;
+	case 222: // SBC A,n
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_read_param_8(processor),1,1);
+		return (7);
+	break;
+	case 223: // RST 18H
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=24;
+		return (11);
+	break;
+	case 224: // RET PO
+		if (0==(F_PV&processor->Rm.br.F)) {
+			processor->PC=Z80free_doPop(processor);
+			return (11);
+		} else {
+			return (5);
+		}
+	break;
+	case 225: // POP HL
+		processor->Rm.wr.HL=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 226: // JP PO,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (0==(F_PV&processor->Rm.br.F)) {
+			processor->PC=tmp2;
+			return (10);
+		} else {
+			return (10);
+		}
+	break;
+	case 227: // EX (SP),HL
+		tmp2=Z80free_read16(processor, processor->Rm.wr.SP);
+		Z80free_write16(processor, processor->Rm.wr.SP,processor->Rm.wr.HL);
+		processor->Rm.wr.HL=tmp2;
+		return (19);
+	break;
+	case 228: // CALL PO,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (0==(F_PV&processor->Rm.br.F)) {
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=tmp2;
+			return (17);
+		} else {
+			return (10);
+		}
+	break;
+	case 229: // PUSH HL
+		Z80free_doPush(processor,processor->Rm.wr.HL);
+		return (11);
+	break;
+	case 230: // AND n
+		Z80free_doAND(processor,Z80free_read_param_8(processor));
+		return (7);
+	break;
+	case 231: // RST 20H
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=32;
+		return (11);
+	break;
+	case 232: // RET PE
+		if (F_PV&processor->Rm.br.F) {
+			processor->PC=Z80free_doPop(processor);
+			return (11);
+		} else {
+			return (5);
+		}
+	break;
+	case 233: // JP HL
+		tmp2=processor->Rm.wr.HL;
+		processor->PC=tmp2;
+		return (4);
+	break;
+	case 234: // JP PE,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (F_PV&processor->Rm.br.F) {
+			processor->PC=tmp2;
+			return (10);
+		} else {
+			return (10);
+		}
+	break;
+	case 235: // EX DE,HL
+		tmp2=processor->Rm.wr.DE;
+		processor->Rm.wr.DE=processor->Rm.wr.HL;
+		processor->Rm.wr.HL=tmp2;
+		return (4);
+	break;
+	case 236: // CALL PE,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (F_PV&processor->Rm.br.F) {
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=tmp2;
+			return (17);
+		} else {
+			return (10);
+		}
+	break;
+	case 238: // XOR n
+		Z80free_doXOR(processor,Z80free_read_param_8(processor));
+		return (7);
+	break;
+	case 239: // RST 28H
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=40;
+		return (11);
+	break;
+	case 240: // RET P
+		if (0==(F_S&processor->Rm.br.F)) {
+			processor->PC=Z80free_doPop(processor);
+			return (11);
+		} else {
+			return (5);
+		}
+	break;
+	case 241: // POP AF
+		processor->Rm.wr.AF=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 242: // JP P,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (0==(F_S&processor->Rm.br.F)) {
+			processor->PC=tmp2;
+			return (10);
+		} else {
+			return (10);
+		}
+	break;
+	case 243: // DI
+		processor->IFF1=0;
+		processor->IFF2=0;
+		return (4);
+	break;
+	case 244: // CALL P,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (0==(F_S&processor->Rm.br.F)) {
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=tmp2;
+			return (17);
+		} else {
+			return (10);
+		}
+	break;
+	case 245: // PUSH AF
+		Z80free_doPush(processor,processor->Rm.wr.AF);
+		return (11);
+	break;
+	case 246: // OR n
+		Z80free_doOR(processor,Z80free_read_param_8(processor));
+		return (7);
+	break;
+	case 247: // RST 30H
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=48;
+		return (11);
+	break;
+	case 248: // RET M
+		if (F_S&processor->Rm.br.F) {
+			processor->PC=Z80free_doPop(processor);
+			return (11);
+		} else {
+			return (5);
+		}
+	break;
+	case 249: // LD SP,HL
+		processor->Rm.wr.SP=processor->Rm.wr.HL;
+		return (6);
+	break;
+	case 250: // JP M,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (F_S&processor->Rm.br.F) {
+			processor->PC=tmp2;
+			return (10);
+		} else {
+			return (10);
+		}
+	break;
+	case 251: // EI
+		processor->IFF1=2; /* this allows to delay one instruction the interrupts*/
+		processor->IFF2=1;
+		return (4);
+	break;
+	case 252: // CALL M,nn
+		tmp2=Z80free_read_param_16(processor);
+		if (F_S&processor->Rm.br.F) {
+			Z80free_doPush(processor,processor->PC);
+			processor->PC=tmp2;
+			return (17);
+		} else {
+			return (10);
+		}
+	break;
+	case 254: // CP n
+		tmp1=Z80free_read_param_8(processor);
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (7);
+	break;
+	case 255: // RST 38H
+		Z80free_doPush(processor,processor->PC);
+		processor->PC=56;
+		return (11);
+	break;
+	}
+
+	return -1;
+}
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free_codesCB.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesCB.c
--- fuse-1.6.0/peripherals/disk/z80free/Z80free_codesCB.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesCB.c	2023-08-07 09:56:42.531706621 +0200
@@ -0,0 +1,1052 @@
+/*
+ * Copyright (C) 2008-2009 Sergio Costas (Raster Software Vigo)
+ * This file is part of Z80Free
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ */
+
+#include "Z80free.h"
+
+int Z80free_codesCB (Z80FREE *processor,byte opcode) {
+
+	switch(opcode) {
+	case 0: // RLC B
+		processor->Rm.br.B=Z80free_doRLC(processor,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 1: // RLC C
+		processor->Rm.br.C=Z80free_doRLC(processor,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 2: // RLC D
+		processor->Rm.br.D=Z80free_doRLC(processor,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 3: // RLC E
+		processor->Rm.br.E=Z80free_doRLC(processor,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 4: // RLC H
+		processor->Rm.br.H=Z80free_doRLC(processor,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 5: // RLC L
+		processor->Rm.br.L=Z80free_doRLC(processor,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 6: // RLC b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 7: // RLC A
+		processor->Rm.br.A=Z80free_doRLC(processor,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 8: // RRC B
+		processor->Rm.br.B=Z80free_doRRC(processor,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 9: // RRC C
+		processor->Rm.br.C=Z80free_doRRC(processor,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 10: // RRC D
+		processor->Rm.br.D=Z80free_doRRC(processor,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 11: // RRC E
+		processor->Rm.br.E=Z80free_doRRC(processor,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 12: // RRC H
+		processor->Rm.br.H=Z80free_doRRC(processor,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 13: // RRC L
+		processor->Rm.br.L=Z80free_doRRC(processor,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 14: // RRC b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 15: // RRC A
+		processor->Rm.br.A=Z80free_doRRC(processor,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 16: // RL B
+		processor->Rm.br.B=Z80free_doRL(processor,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 17: // RL C
+		processor->Rm.br.C=Z80free_doRL(processor,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 18: // RL D
+		processor->Rm.br.D=Z80free_doRL(processor,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 19: // RL E
+		processor->Rm.br.E=Z80free_doRL(processor,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 20: // RL H
+		processor->Rm.br.H=Z80free_doRL(processor,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 21: // RL L
+		processor->Rm.br.L=Z80free_doRL(processor,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 22: // RL b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 23: // RL A
+		processor->Rm.br.A=Z80free_doRL(processor,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 24: // RR B
+		processor->Rm.br.B=Z80free_doRR(processor,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 25: // RR C
+		processor->Rm.br.C=Z80free_doRR(processor,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 26: // RR D
+		processor->Rm.br.D=Z80free_doRR(processor,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 27: // RR E
+		processor->Rm.br.E=Z80free_doRR(processor,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 28: // RR H
+		processor->Rm.br.H=Z80free_doRR(processor,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 29: // RR L
+		processor->Rm.br.L=Z80free_doRR(processor,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 30: // RR b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 31: // RR A
+		processor->Rm.br.A=Z80free_doRR(processor,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 32: // SLA B
+		processor->Rm.br.B=Z80free_doSL(processor,0,processor->Rm.br.B);
+		return (4);
+	break;
+	case 33: // SLA C
+		processor->Rm.br.C=Z80free_doSL(processor,0,processor->Rm.br.C);
+		return (4);
+	break;
+	case 34: // SLA D
+		processor->Rm.br.D=Z80free_doSL(processor,0,processor->Rm.br.D);
+		return (4);
+	break;
+	case 35: // SLA E
+		processor->Rm.br.E=Z80free_doSL(processor,0,processor->Rm.br.E);
+		return (4);
+	break;
+	case 36: // SLA H
+		processor->Rm.br.H=Z80free_doSL(processor,0,processor->Rm.br.H);
+		return (4);
+	break;
+	case 37: // SLA L
+		processor->Rm.br.L=Z80free_doSL(processor,0,processor->Rm.br.L);
+		return (4);
+	break;
+	case 38: // SLA b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 39: // SLA A
+		processor->Rm.br.A=Z80free_doSL(processor,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 40: // SRA B
+		processor->Rm.br.B=Z80free_doSR(processor,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 41: // SRA C
+		processor->Rm.br.C=Z80free_doSR(processor,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 42: // SRA D
+		processor->Rm.br.D=Z80free_doSR(processor,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 43: // SRA E
+		processor->Rm.br.E=Z80free_doSR(processor,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 44: // SRA H
+		processor->Rm.br.H=Z80free_doSR(processor,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 45: // SRA L
+		processor->Rm.br.L=Z80free_doSR(processor,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 46: // SRA b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 47: // SRA A
+		processor->Rm.br.A=Z80free_doSR(processor,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 48: // SLL B
+		processor->Rm.br.B=Z80free_doSL(processor,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 49: // SLL C
+		processor->Rm.br.C=Z80free_doSL(processor,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 50: // SLL D
+		processor->Rm.br.D=Z80free_doSL(processor,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 51: // SLL E
+		processor->Rm.br.E=Z80free_doSL(processor,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 52: // SLL H
+		processor->Rm.br.H=Z80free_doSL(processor,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 53: // SLL L
+		processor->Rm.br.L=Z80free_doSL(processor,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 54: // SLL b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 55: // SLL A
+		processor->Rm.br.A=Z80free_doSL(processor,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 56: // SRL B
+		processor->Rm.br.B=Z80free_doSR(processor,0,processor->Rm.br.B);
+		return (4);
+	break;
+	case 57: // SRL C
+		processor->Rm.br.C=Z80free_doSR(processor,0,processor->Rm.br.C);
+		return (4);
+	break;
+	case 58: // SRL D
+		processor->Rm.br.D=Z80free_doSR(processor,0,processor->Rm.br.D);
+		return (4);
+	break;
+	case 59: // SRL E
+		processor->Rm.br.E=Z80free_doSR(processor,0,processor->Rm.br.E);
+		return (4);
+	break;
+	case 60: // SRL H
+		processor->Rm.br.H=Z80free_doSR(processor,0,processor->Rm.br.H);
+		return (4);
+	break;
+	case 61: // SRL L
+		processor->Rm.br.L=Z80free_doSR(processor,0,processor->Rm.br.L);
+		return (4);
+	break;
+	case 62: // SRL b(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 63: // SRL A
+		processor->Rm.br.A=Z80free_doSR(processor,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 64: // BIT 0,B
+		Z80free_doBIT(processor,0,processor->Rm.br.B);
+		return (4);
+	break;
+	case 65: // BIT 0,C
+		Z80free_doBIT(processor,0,processor->Rm.br.C);
+		return (4);
+	break;
+	case 66: // BIT 0,D
+		Z80free_doBIT(processor,0,processor->Rm.br.D);
+		return (4);
+	break;
+	case 67: // BIT 0,E
+		Z80free_doBIT(processor,0,processor->Rm.br.E);
+		return (4);
+	break;
+	case 68: // BIT 0,H
+		Z80free_doBIT(processor,0,processor->Rm.br.H);
+		return (4);
+	break;
+	case 69: // BIT 0,L
+		Z80free_doBIT(processor,0,processor->Rm.br.L);
+		return (4);
+	break;
+	case 70: // BIT 0,(HL)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (8);
+	break;
+	case 71: // BIT 0,A
+		Z80free_doBIT(processor,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 72: // BIT 1,B
+		Z80free_doBIT(processor,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 73: // BIT 1,C
+		Z80free_doBIT(processor,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 74: // BIT 1,D
+		Z80free_doBIT(processor,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 75: // BIT 1,E
+		Z80free_doBIT(processor,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 76: // BIT 1,H
+		Z80free_doBIT(processor,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 77: // BIT 1,L
+		Z80free_doBIT(processor,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 78: // BIT 1,(HL)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (8);
+	break;
+	case 79: // BIT 1,A
+		Z80free_doBIT(processor,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 80: // BIT 2,B
+		Z80free_doBIT(processor,2,processor->Rm.br.B);
+		return (4);
+	break;
+	case 81: // BIT 2,C
+		Z80free_doBIT(processor,2,processor->Rm.br.C);
+		return (4);
+	break;
+	case 82: // BIT 2,D
+		Z80free_doBIT(processor,2,processor->Rm.br.D);
+		return (4);
+	break;
+	case 83: // BIT 2,E
+		Z80free_doBIT(processor,2,processor->Rm.br.E);
+		return (4);
+	break;
+	case 84: // BIT 2,H
+		Z80free_doBIT(processor,2,processor->Rm.br.H);
+		return (4);
+	break;
+	case 85: // BIT 2,L
+		Z80free_doBIT(processor,2,processor->Rm.br.L);
+		return (4);
+	break;
+	case 86: // BIT 2,(HL)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (8);
+	break;
+	case 87: // BIT 2,A
+		Z80free_doBIT(processor,2,processor->Rm.br.A);
+		return (4);
+	break;
+	case 88: // BIT 3,B
+		Z80free_doBIT(processor,3,processor->Rm.br.B);
+		return (4);
+	break;
+	case 89: // BIT 3,C
+		Z80free_doBIT(processor,3,processor->Rm.br.C);
+		return (4);
+	break;
+	case 90: // BIT 3,D
+		Z80free_doBIT(processor,3,processor->Rm.br.D);
+		return (4);
+	break;
+	case 91: // BIT 3,E
+		Z80free_doBIT(processor,3,processor->Rm.br.E);
+		return (4);
+	break;
+	case 92: // BIT 3,H
+		Z80free_doBIT(processor,3,processor->Rm.br.H);
+		return (4);
+	break;
+	case 93: // BIT 3,L
+		Z80free_doBIT(processor,3,processor->Rm.br.L);
+		return (4);
+	break;
+	case 94: // BIT 3,(HL)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (8);
+	break;
+	case 95: // BIT 3,A
+		Z80free_doBIT(processor,3,processor->Rm.br.A);
+		return (4);
+	break;
+	case 96: // BIT 4,B
+		Z80free_doBIT(processor,4,processor->Rm.br.B);
+		return (4);
+	break;
+	case 97: // BIT 4,C
+		Z80free_doBIT(processor,4,processor->Rm.br.C);
+		return (4);
+	break;
+	case 98: // BIT 4,D
+		Z80free_doBIT(processor,4,processor->Rm.br.D);
+		return (4);
+	break;
+	case 99: // BIT 4,E
+		Z80free_doBIT(processor,4,processor->Rm.br.E);
+		return (4);
+	break;
+	case 100: // BIT 4,H
+		Z80free_doBIT(processor,4,processor->Rm.br.H);
+		return (4);
+	break;
+	case 101: // BIT 4,L
+		Z80free_doBIT(processor,4,processor->Rm.br.L);
+		return (4);
+	break;
+	case 102: // BIT 4,(HL)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (8);
+	break;
+	case 103: // BIT 4,A
+		Z80free_doBIT(processor,4,processor->Rm.br.A);
+		return (4);
+	break;
+	case 104: // BIT 5,B
+		Z80free_doBIT(processor,5,processor->Rm.br.B);
+		return (4);
+	break;
+	case 105: // BIT 5,C
+		Z80free_doBIT(processor,5,processor->Rm.br.C);
+		return (4);
+	break;
+	case 106: // BIT 5,D
+		Z80free_doBIT(processor,5,processor->Rm.br.D);
+		return (4);
+	break;
+	case 107: // BIT 5,E
+		Z80free_doBIT(processor,5,processor->Rm.br.E);
+		return (4);
+	break;
+	case 108: // BIT 5,H
+		Z80free_doBIT(processor,5,processor->Rm.br.H);
+		return (4);
+	break;
+	case 109: // BIT 5,L
+		Z80free_doBIT(processor,5,processor->Rm.br.L);
+		return (4);
+	break;
+	case 110: // BIT 5,(HL)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (8);
+	break;
+	case 111: // BIT 5,A
+		Z80free_doBIT(processor,5,processor->Rm.br.A);
+		return (4);
+	break;
+	case 112: // BIT 6,B
+		Z80free_doBIT(processor,6,processor->Rm.br.B);
+		return (4);
+	break;
+	case 113: // BIT 6,C
+		Z80free_doBIT(processor,6,processor->Rm.br.C);
+		return (4);
+	break;
+	case 114: // BIT 6,D
+		Z80free_doBIT(processor,6,processor->Rm.br.D);
+		return (4);
+	break;
+	case 115: // BIT 6,E
+		Z80free_doBIT(processor,6,processor->Rm.br.E);
+		return (4);
+	break;
+	case 116: // BIT 6,H
+		Z80free_doBIT(processor,6,processor->Rm.br.H);
+		return (4);
+	break;
+	case 117: // BIT 6,L
+		Z80free_doBIT(processor,6,processor->Rm.br.L);
+		return (4);
+	break;
+	case 118: // BIT 6,(HL)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (8);
+	break;
+	case 119: // BIT 6,A
+		Z80free_doBIT(processor,6,processor->Rm.br.A);
+		return (4);
+	break;
+	case 120: // BIT 7,B
+		Z80free_doBIT(processor,7,processor->Rm.br.B);
+		return (4);
+	break;
+	case 121: // BIT 7,C
+		Z80free_doBIT(processor,7,processor->Rm.br.C);
+		return (4);
+	break;
+	case 122: // BIT 7,D
+		Z80free_doBIT(processor,7,processor->Rm.br.D);
+		return (4);
+	break;
+	case 123: // BIT 7,E
+		Z80free_doBIT(processor,7,processor->Rm.br.E);
+		return (4);
+	break;
+	case 124: // BIT 7,H
+		Z80free_doBIT(processor,7,processor->Rm.br.H);
+		return (4);
+	break;
+	case 125: // BIT 7,L
+		Z80free_doBIT(processor,7,processor->Rm.br.L);
+		return (4);
+	break;
+	case 126: // BIT 7,(HL)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,processor->Rm.wr.HL));
+		return (8);
+	break;
+	case 127: // BIT 7,A
+		Z80free_doBIT(processor,7,processor->Rm.br.A);
+		return (4);
+	break;
+	case 128: // RES 0,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,0,0,processor->Rm.br.B);
+		return (4);
+	break;
+	case 129: // RES 0,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,0,0,processor->Rm.br.C);
+		return (4);
+	break;
+	case 130: // RES 0,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,0,0,processor->Rm.br.D);
+		return (4);
+	break;
+	case 131: // RES 0,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,0,0,processor->Rm.br.E);
+		return (4);
+	break;
+	case 132: // RES 0,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,0,0,processor->Rm.br.H);
+		return (4);
+	break;
+	case 133: // RES 0,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,0,0,processor->Rm.br.L);
+		return (4);
+	break;
+	case 134: // RES 0,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 135: // RES 0,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,0,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 136: // RES 1,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,0,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 137: // RES 1,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,0,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 138: // RES 1,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,0,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 139: // RES 1,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,0,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 140: // RES 1,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,0,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 141: // RES 1,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,0,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 142: // RES 1,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 143: // RES 1,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,0,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 144: // RES 2,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,0,2,processor->Rm.br.B);
+		return (4);
+	break;
+	case 145: // RES 2,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,0,2,processor->Rm.br.C);
+		return (4);
+	break;
+	case 146: // RES 2,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,0,2,processor->Rm.br.D);
+		return (4);
+	break;
+	case 147: // RES 2,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,0,2,processor->Rm.br.E);
+		return (4);
+	break;
+	case 148: // RES 2,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,0,2,processor->Rm.br.H);
+		return (4);
+	break;
+	case 149: // RES 2,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,0,2,processor->Rm.br.L);
+		return (4);
+	break;
+	case 150: // RES 2,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 151: // RES 2,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,0,2,processor->Rm.br.A);
+		return (4);
+	break;
+	case 152: // RES 3,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,0,3,processor->Rm.br.B);
+		return (4);
+	break;
+	case 153: // RES 3,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,0,3,processor->Rm.br.C);
+		return (4);
+	break;
+	case 154: // RES 3,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,0,3,processor->Rm.br.D);
+		return (4);
+	break;
+	case 155: // RES 3,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,0,3,processor->Rm.br.E);
+		return (4);
+	break;
+	case 156: // RES 3,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,0,3,processor->Rm.br.H);
+		return (4);
+	break;
+	case 157: // RES 3,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,0,3,processor->Rm.br.L);
+		return (4);
+	break;
+	case 158: // RES 3,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 159: // RES 3,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,0,3,processor->Rm.br.A);
+		return (4);
+	break;
+	case 160: // RES 4,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,0,4,processor->Rm.br.B);
+		return (4);
+	break;
+	case 161: // RES 4,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,0,4,processor->Rm.br.C);
+		return (4);
+	break;
+	case 162: // RES 4,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,0,4,processor->Rm.br.D);
+		return (4);
+	break;
+	case 163: // RES 4,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,0,4,processor->Rm.br.E);
+		return (4);
+	break;
+	case 164: // RES 4,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,0,4,processor->Rm.br.H);
+		return (4);
+	break;
+	case 165: // RES 4,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,0,4,processor->Rm.br.L);
+		return (4);
+	break;
+	case 166: // RES 4,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 167: // RES 4,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,0,4,processor->Rm.br.A);
+		return (4);
+	break;
+	case 168: // RES 5,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,0,5,processor->Rm.br.B);
+		return (4);
+	break;
+	case 169: // RES 5,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,0,5,processor->Rm.br.C);
+		return (4);
+	break;
+	case 170: // RES 5,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,0,5,processor->Rm.br.D);
+		return (4);
+	break;
+	case 171: // RES 5,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,0,5,processor->Rm.br.E);
+		return (4);
+	break;
+	case 172: // RES 5,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,0,5,processor->Rm.br.H);
+		return (4);
+	break;
+	case 173: // RES 5,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,0,5,processor->Rm.br.L);
+		return (4);
+	break;
+	case 174: // RES 5,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 175: // RES 5,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,0,5,processor->Rm.br.A);
+		return (4);
+	break;
+	case 176: // RES 6,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,0,6,processor->Rm.br.B);
+		return (4);
+	break;
+	case 177: // RES 6,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,0,6,processor->Rm.br.C);
+		return (4);
+	break;
+	case 178: // RES 6,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,0,6,processor->Rm.br.D);
+		return (4);
+	break;
+	case 179: // RES 6,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,0,6,processor->Rm.br.E);
+		return (4);
+	break;
+	case 180: // RES 6,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,0,6,processor->Rm.br.H);
+		return (4);
+	break;
+	case 181: // RES 6,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,0,6,processor->Rm.br.L);
+		return (4);
+	break;
+	case 182: // RES 6,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 183: // RES 6,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,0,6,processor->Rm.br.A);
+		return (4);
+	break;
+	case 184: // RES 7,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,0,7,processor->Rm.br.B);
+		return (4);
+	break;
+	case 185: // RES 7,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,0,7,processor->Rm.br.C);
+		return (4);
+	break;
+	case 186: // RES 7,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,0,7,processor->Rm.br.D);
+		return (4);
+	break;
+	case 187: // RES 7,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,0,7,processor->Rm.br.E);
+		return (4);
+	break;
+	case 188: // RES 7,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,0,7,processor->Rm.br.H);
+		return (4);
+	break;
+	case 189: // RES 7,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,0,7,processor->Rm.br.L);
+		return (4);
+	break;
+	case 190: // RES 7,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 191: // RES 7,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,0,7,processor->Rm.br.A);
+		return (4);
+	break;
+	case 192: // SET 0,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,1,0,processor->Rm.br.B);
+		return (4);
+	break;
+	case 193: // SET 0,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,1,0,processor->Rm.br.C);
+		return (4);
+	break;
+	case 194: // SET 0,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,1,0,processor->Rm.br.D);
+		return (4);
+	break;
+	case 195: // SET 0,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,1,0,processor->Rm.br.E);
+		return (4);
+	break;
+	case 196: // SET 0,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,1,0,processor->Rm.br.H);
+		return (4);
+	break;
+	case 197: // SET 0,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,1,0,processor->Rm.br.L);
+		return (4);
+	break;
+	case 198: // SET 0,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 199: // SET 0,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,1,0,processor->Rm.br.A);
+		return (4);
+	break;
+	case 200: // SET 1,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,1,1,processor->Rm.br.B);
+		return (4);
+	break;
+	case 201: // SET 1,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,1,1,processor->Rm.br.C);
+		return (4);
+	break;
+	case 202: // SET 1,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,1,1,processor->Rm.br.D);
+		return (4);
+	break;
+	case 203: // SET 1,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,1,1,processor->Rm.br.E);
+		return (4);
+	break;
+	case 204: // SET 1,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,1,1,processor->Rm.br.H);
+		return (4);
+	break;
+	case 205: // SET 1,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,1,1,processor->Rm.br.L);
+		return (4);
+	break;
+	case 206: // SET 1,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 207: // SET 1,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,1,1,processor->Rm.br.A);
+		return (4);
+	break;
+	case 208: // SET 2,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,1,2,processor->Rm.br.B);
+		return (4);
+	break;
+	case 209: // SET 2,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,1,2,processor->Rm.br.C);
+		return (4);
+	break;
+	case 210: // SET 2,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,1,2,processor->Rm.br.D);
+		return (4);
+	break;
+	case 211: // SET 2,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,1,2,processor->Rm.br.E);
+		return (4);
+	break;
+	case 212: // SET 2,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,1,2,processor->Rm.br.H);
+		return (4);
+	break;
+	case 213: // SET 2,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,1,2,processor->Rm.br.L);
+		return (4);
+	break;
+	case 214: // SET 2,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 215: // SET 2,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,1,2,processor->Rm.br.A);
+		return (4);
+	break;
+	case 216: // SET 3,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,1,3,processor->Rm.br.B);
+		return (4);
+	break;
+	case 217: // SET 3,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,1,3,processor->Rm.br.C);
+		return (4);
+	break;
+	case 218: // SET 3,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,1,3,processor->Rm.br.D);
+		return (4);
+	break;
+	case 219: // SET 3,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,1,3,processor->Rm.br.E);
+		return (4);
+	break;
+	case 220: // SET 3,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,1,3,processor->Rm.br.H);
+		return (4);
+	break;
+	case 221: // SET 3,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,1,3,processor->Rm.br.L);
+		return (4);
+	break;
+	case 222: // SET 3,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 223: // SET 3,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,1,3,processor->Rm.br.A);
+		return (4);
+	break;
+	case 224: // SET 4,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,1,4,processor->Rm.br.B);
+		return (4);
+	break;
+	case 225: // SET 4,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,1,4,processor->Rm.br.C);
+		return (4);
+	break;
+	case 226: // SET 4,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,1,4,processor->Rm.br.D);
+		return (4);
+	break;
+	case 227: // SET 4,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,1,4,processor->Rm.br.E);
+		return (4);
+	break;
+	case 228: // SET 4,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,1,4,processor->Rm.br.H);
+		return (4);
+	break;
+	case 229: // SET 4,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,1,4,processor->Rm.br.L);
+		return (4);
+	break;
+	case 230: // SET 4,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 231: // SET 4,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,1,4,processor->Rm.br.A);
+		return (4);
+	break;
+	case 232: // SET 5,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,1,5,processor->Rm.br.B);
+		return (4);
+	break;
+	case 233: // SET 5,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,1,5,processor->Rm.br.C);
+		return (4);
+	break;
+	case 234: // SET 5,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,1,5,processor->Rm.br.D);
+		return (4);
+	break;
+	case 235: // SET 5,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,1,5,processor->Rm.br.E);
+		return (4);
+	break;
+	case 236: // SET 5,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,1,5,processor->Rm.br.H);
+		return (4);
+	break;
+	case 237: // SET 5,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,1,5,processor->Rm.br.L);
+		return (4);
+	break;
+	case 238: // SET 5,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 239: // SET 5,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,1,5,processor->Rm.br.A);
+		return (4);
+	break;
+	case 240: // SET 6,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,1,6,processor->Rm.br.B);
+		return (4);
+	break;
+	case 241: // SET 6,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,1,6,processor->Rm.br.C);
+		return (4);
+	break;
+	case 242: // SET 6,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,1,6,processor->Rm.br.D);
+		return (4);
+	break;
+	case 243: // SET 6,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,1,6,processor->Rm.br.E);
+		return (4);
+	break;
+	case 244: // SET 6,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,1,6,processor->Rm.br.H);
+		return (4);
+	break;
+	case 245: // SET 6,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,1,6,processor->Rm.br.L);
+		return (4);
+	break;
+	case 246: // SET 6,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 247: // SET 6,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,1,6,processor->Rm.br.A);
+		return (4);
+	break;
+	case 248: // SET 7,B
+		processor->Rm.br.B=Z80free_doSetRes(processor,1,7,processor->Rm.br.B);
+		return (4);
+	break;
+	case 249: // SET 7,C
+		processor->Rm.br.C=Z80free_doSetRes(processor,1,7,processor->Rm.br.C);
+		return (4);
+	break;
+	case 250: // SET 7,D
+		processor->Rm.br.D=Z80free_doSetRes(processor,1,7,processor->Rm.br.D);
+		return (4);
+	break;
+	case 251: // SET 7,E
+		processor->Rm.br.E=Z80free_doSetRes(processor,1,7,processor->Rm.br.E);
+		return (4);
+	break;
+	case 252: // SET 7,H
+		processor->Rm.br.H=Z80free_doSetRes(processor,1,7,processor->Rm.br.H);
+		return (4);
+	break;
+	case 253: // SET 7,L
+		processor->Rm.br.L=Z80free_doSetRes(processor,1,7,processor->Rm.br.L);
+		return (4);
+	break;
+	case 254: // SET 7,(HL)
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,processor->Rm.wr.HL)));
+		return (11);
+	break;
+	case 255: // SET 7,A
+		processor->Rm.br.A=Z80free_doSetRes(processor,1,7,processor->Rm.br.A);
+		return (4);
+	break;
+	}
+
+	return -1;
+}
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free_codesDD.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesDD.c
--- fuse-1.6.0/peripherals/disk/z80free/Z80free_codesDD.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesDD.c	2023-08-07 09:56:42.531706621 +0200
@@ -0,0 +1,890 @@
+/*
+ * Copyright (C) 2008-2009 Sergio Costas (Raster Software Vigo)
+ * This file is part of Z80Free
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ */
+
+#include "Z80free.h"
+
+int Z80free_codesDD (Z80FREE *processor,byte opcode) {
+	static byte tmp1;
+	static word tmp2;
+
+	switch(opcode) {
+	case 0: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 1: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 2: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 3: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 4: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 5: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 6: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 7: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 8: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 9: // ADD IX,BC
+		processor->Rm.wr.IX=Z80free_doArithmetic16(processor,processor->Rm.wr.IX,processor->Rm.wr.BC,0,0);
+		return (11);
+	break;
+	case 10: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 11: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 12: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 13: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 14: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 15: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 16: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 17: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 18: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 19: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 20: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 21: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 22: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 23: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 24: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 25: // ADD IX,DE
+		processor->Rm.wr.IX=Z80free_doArithmetic16(processor,processor->Rm.wr.IX,processor->Rm.wr.DE,0,0);
+		return (11);
+	break;
+	case 26: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 27: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 28: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 29: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 30: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 31: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 32: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 33: // LD IX,nn
+		processor->Rm.wr.IX=Z80free_read_param_16(processor);
+		return (10);
+	break;
+	case 34: // LD (nn),IX
+		Z80free_write16(processor, Z80free_read_param_16(processor),processor->Rm.wr.IX);
+		return (16);
+	break;
+	case 35: // INC IX
+		processor->Rm.wr.IX=Z80free_doIncDec16(processor,processor->Rm.wr.IX,0);
+		return (6);
+	break;
+	case 36: // INC IXH
+		processor->Rm.br.IXh=Z80free_doIncDec(processor,processor->Rm.br.IXh,0);
+		return (4);
+	break;
+	case 37: // DEC IXH
+		processor->Rm.br.IXh=Z80free_doIncDec(processor,processor->Rm.br.IXh,1);
+		return (4);
+	break;
+	case 38: // LD IXH,n
+		processor->Rm.br.IXh=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 39: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 40: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 41: // ADD IX,IX
+		processor->Rm.wr.IX=Z80free_doArithmetic16(processor,processor->Rm.wr.IX,processor->Rm.wr.IX,0,0);
+		return (11);
+	break;
+	case 42: // LD IX,(nn)
+		processor->Rm.wr.IX=Z80free_read16(processor, Z80free_read_param_16(processor));
+		return (16);
+	break;
+	case 43: // DEC IX
+		processor->Rm.wr.IX=Z80free_doIncDec16(processor,processor->Rm.wr.IX,1);
+		return (6);
+	break;
+	case 44: // INC IXL
+		processor->Rm.br.IXl=Z80free_doIncDec(processor,processor->Rm.br.IXl,0);
+		return (4);
+	break;
+	case 45: // DEC IXL
+		processor->Rm.br.IXl=Z80free_doIncDec(processor,processor->Rm.br.IXl,1);
+		return (4);
+	break;
+	case 46: // LD IXL,n
+		processor->Rm.br.IXl=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 47: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 48: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 49: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 50: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 51: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 52: // INC b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),Z80free_doIncDec(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)),0));
+		return (19);
+	break;
+	case 53: // DEC b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),Z80free_doIncDec(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)),1));
+		return (19);
+	break;
+	case 54: // LD2 IX+d,n
+		tmp2=Z80free_addr_relative(processor,processor->Rm.wr.IX);
+		Z80free_Wr_Internal(processor,tmp2,Z80free_read_param_8(processor));
+		return (15);
+	break;
+	case 55: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 56: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 57: // ADD IX,SP
+		processor->Rm.wr.IX=Z80free_doArithmetic16(processor,processor->Rm.wr.IX,processor->Rm.wr.SP,0,0);
+		return (11);
+	break;
+	case 58: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 59: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 60: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 61: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 62: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 63: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 64: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 65: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 66: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 67: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 68: // LD B,IXH
+		processor->Rm.br.B=processor->Rm.br.IXh;
+		return (4);
+	break;
+	case 69: // LD B,IXL
+		processor->Rm.br.B=processor->Rm.br.IXl;
+		return (4);
+	break;
+	case 70: // LD B,(IX+d)
+		processor->Rm.br.B=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX));
+		return (15);
+	break;
+	case 71: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 72: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 73: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 74: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 75: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 76: // LD C,IXH
+		processor->Rm.br.C=processor->Rm.br.IXh;
+		return (4);
+	break;
+	case 77: // LD C,IXL
+		processor->Rm.br.C=processor->Rm.br.IXl;
+		return (4);
+	break;
+	case 78: // LD C,(IX+d)
+		processor->Rm.br.C=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX));
+		return (15);
+	break;
+	case 79: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 80: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 81: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 82: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 83: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 84: // LD D,IXH
+		processor->Rm.br.D=processor->Rm.br.IXh;
+		return (4);
+	break;
+	case 85: // LD D,IXL
+		processor->Rm.br.D=processor->Rm.br.IXl;
+		return (4);
+	break;
+	case 86: // LD D,(IX+d)
+		processor->Rm.br.D=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX));
+		return (15);
+	break;
+	case 87: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 88: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 89: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 90: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 91: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 92: // LD E,IXH
+		processor->Rm.br.E=processor->Rm.br.IXh;
+		return (4);
+	break;
+	case 93: // LD E,IXL
+		processor->Rm.br.E=processor->Rm.br.IXl;
+		return (4);
+	break;
+	case 94: // LD E,(IX+d)
+		processor->Rm.br.E=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX));
+		return (15);
+	break;
+	case 95: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 96: // LD IXH,B
+		processor->Rm.br.IXh=processor->Rm.br.B;
+		return (4);
+	break;
+	case 97: // LD IXH,C
+		processor->Rm.br.IXh=processor->Rm.br.C;
+		return (4);
+	break;
+	case 98: // LD IXH,D
+		processor->Rm.br.IXh=processor->Rm.br.D;
+		return (4);
+	break;
+	case 99: // LD IXH,E
+		processor->Rm.br.IXh=processor->Rm.br.E;
+		return (4);
+	break;
+	case 100: // LD IXH,IXH
+		processor->Rm.br.IXh=processor->Rm.br.IXh;
+		return (4);
+	break;
+	case 101: // LD IXH,IXL
+		processor->Rm.br.IXh=processor->Rm.br.IXl;
+		return (4);
+	break;
+	case 102: // LD H,(IX+d)
+		processor->Rm.br.H=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX));
+		return (15);
+	break;
+	case 103: // LD IXH,A
+		processor->Rm.br.IXh=processor->Rm.br.A;
+		return (4);
+	break;
+	case 104: // LD IXL,B
+		processor->Rm.br.IXl=processor->Rm.br.B;
+		return (4);
+	break;
+	case 105: // LD IXL,C
+		processor->Rm.br.IXl=processor->Rm.br.C;
+		return (4);
+	break;
+	case 106: // LD IXL,D
+		processor->Rm.br.IXl=processor->Rm.br.D;
+		return (4);
+	break;
+	case 107: // LD IXL,E
+		processor->Rm.br.IXl=processor->Rm.br.E;
+		return (4);
+	break;
+	case 108: // LD IXL,IXH
+		processor->Rm.br.IXl=processor->Rm.br.IXh;
+		return (4);
+	break;
+	case 109: // LD IXL,IXL
+		processor->Rm.br.IXl=processor->Rm.br.IXl;
+		return (4);
+	break;
+	case 110: // LD L,(IX+d)
+		processor->Rm.br.L=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX));
+		return (15);
+	break;
+	case 111: // LD IXL,A
+		processor->Rm.br.IXl=processor->Rm.br.A;
+		return (4);
+	break;
+	case 112: // LD (IX+d),B
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),processor->Rm.br.B);
+		return (15);
+	break;
+	case 113: // LD (IX+d),C
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),processor->Rm.br.C);
+		return (15);
+	break;
+	case 114: // LD (IX+d),D
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),processor->Rm.br.D);
+		return (15);
+	break;
+	case 115: // LD (IX+d),E
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),processor->Rm.br.E);
+		return (15);
+	break;
+	case 116: // LD (IX+d),H
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),processor->Rm.br.H);
+		return (15);
+	break;
+	case 117: // LD (IX+d),L
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),processor->Rm.br.L);
+		return (15);
+	break;
+	case 118: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 119: // LD (IX+d),A
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX),processor->Rm.br.A);
+		return (15);
+	break;
+	case 120: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 121: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 122: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 123: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 124: // LD A,IXH
+		processor->Rm.br.A=processor->Rm.br.IXh;
+		return (4);
+	break;
+	case 125: // LD A,IXL
+		processor->Rm.br.A=processor->Rm.br.IXl;
+		return (4);
+	break;
+	case 126: // LD A,(IX+d)
+		processor->Rm.br.A=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX));
+		return (15);
+	break;
+	case 127: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 128: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 129: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 130: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 131: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 132: // ADD A,IXH
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IXh,0,0);
+		return (4);
+	break;
+	case 133: // ADD A,IXL
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IXl,0,0);
+		return (4);
+	break;
+	case 134: // ADD A,(IX+d)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)),0,0);
+		return (15);
+	break;
+	case 135: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 136: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 137: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 138: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 139: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 140: // ADC A,IXH
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IXh,1,0);
+		return (4);
+	break;
+	case 141: // ADC A,IXL
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IXl,1,0);
+		return (4);
+	break;
+	case 142: // ADC A,(IX+d)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)),1,0);
+		return (15);
+	break;
+	case 143: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 144: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 145: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 146: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 147: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 148: // SUB IXH
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IXh,0,1);
+		return (4);
+	break;
+	case 149: // SUB IXL
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IXl,0,1);
+		return (4);
+	break;
+	case 150: // SUB b(IX+d)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)),0,1);
+		return (15);
+	break;
+	case 151: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 152: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 153: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 154: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 155: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 156: // SBC A,IXH
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IXh,1,1);
+		return (4);
+	break;
+	case 157: // SBC A,IXL
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IXl,1,1);
+		return (4);
+	break;
+	case 158: // SBC A,(IX+d)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)),1,1);
+		return (15);
+	break;
+	case 159: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 160: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 161: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 162: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 163: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 164: // AND IXH
+		Z80free_doAND(processor,processor->Rm.br.IXh);
+		return (4);
+	break;
+	case 165: // AND IXL
+		Z80free_doAND(processor,processor->Rm.br.IXl);
+		return (4);
+	break;
+	case 166: // AND b(IX+d)
+		Z80free_doAND(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)));
+		return (15);
+	break;
+	case 167: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 168: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 169: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 170: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 171: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 172: // XOR IXH
+		Z80free_doXOR(processor,processor->Rm.br.IXh);
+		return (4);
+	break;
+	case 173: // XOR IXL
+		Z80free_doXOR(processor,processor->Rm.br.IXl);
+		return (4);
+	break;
+	case 174: // XOR b(IX+d)
+		Z80free_doXOR(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)));
+		return (15);
+	break;
+	case 175: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 176: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 177: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 178: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 179: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 180: // OR IXH
+		Z80free_doOR(processor,processor->Rm.br.IXh);
+		return (4);
+	break;
+	case 181: // OR IXL
+		Z80free_doOR(processor,processor->Rm.br.IXl);
+		return (4);
+	break;
+	case 182: // OR b(IX+d)
+		Z80free_doOR(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX)));
+		return (15);
+	break;
+	case 183: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 184: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 185: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 186: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 187: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 188: // CP IXH
+		tmp1=processor->Rm.br.IXh;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 189: // CP IXL
+		tmp1=processor->Rm.br.IXl;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 190: // CP b(IX+d)
+		tmp1=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IX));
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (15);
+	break;
+	case 191: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 192: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 193: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 194: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 195: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 196: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 197: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 198: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 199: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 200: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 201: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 202: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 204: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 205: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 206: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 207: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 208: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 209: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 210: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 211: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 212: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 213: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 214: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 215: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 216: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 217: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 218: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 219: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 220: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 221: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 222: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 223: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 224: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 225: // POP IX
+		processor->Rm.wr.IX=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 226: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 227: // EX (SP),IX
+		tmp2=Z80free_read16(processor, processor->Rm.wr.SP);
+		Z80free_write16(processor, processor->Rm.wr.SP,processor->Rm.wr.IX);
+		processor->Rm.wr.IX=tmp2;
+		return (19);
+	break;
+	case 228: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 229: // PUSH IX
+		Z80free_doPush(processor,processor->Rm.wr.IX);
+		return (11);
+	break;
+	case 230: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 231: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 232: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 233: // JP IX
+		tmp2=processor->Rm.wr.IX;
+		processor->PC=tmp2;
+		return (4);
+	break;
+	case 234: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 235: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 236: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 237: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 238: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 239: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 240: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 241: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 242: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 243: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 244: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 245: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 246: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 247: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 248: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 249: // LD SP,IX
+		processor->Rm.wr.SP=processor->Rm.wr.IX;
+		return (6);
+	break;
+	case 250: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 251: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 252: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 253: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 254: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 255: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	}
+
+	return -1;
+}
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free_codesDDCB.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesDDCB.c
--- fuse-1.6.0/peripherals/disk/z80free/Z80free_codesDDCB.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesDDCB.c	2023-08-07 09:56:42.531706621 +0200
@@ -0,0 +1,1391 @@
+/*
+ * Copyright (C) 2008-2009 Sergio Costas (Raster Software Vigo)
+ * This file is part of Z80Free
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ */
+
+#include "Z80free.h"
+
+int Z80free_codesDDCB (Z80FREE *processor,byte d1) {
+	static byte tmp1;
+	static byte opcode;
+	opcode=Z80free_Rd_Internal(processor,processor->PC++);
+
+	switch(opcode) {
+	case 0: // LD_RLC B,(IX+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 1: // LD_RLC C,(IX+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 2: // LD_RLC D,(IX+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 3: // LD_RLC E,(IX+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 4: // LD_RLC H,(IX+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 5: // LD_RLC L,(IX+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 6: // RLC b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 7: // LD_RLC A,(IX+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 8: // LD_RRC B,(IX+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 9: // LD_RRC C,(IX+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 10: // LD_RRC D,(IX+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 11: // LD_RRC E,(IX+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 12: // LD_RRC H,(IX+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 13: // LD_RRC L,(IX+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 14: // RRC b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 15: // LD_RRC A,(IX+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 16: // LD_RL B,(IX+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 17: // LD_RL C,(IX+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 18: // LD_RL D,(IX+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 19: // LD_RL E,(IX+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 20: // LD_RL H,(IX+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 21: // LD_RL L,(IX+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 22: // RL b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 23: // LD_RL A,(IX+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 24: // LD_RR B,(IX+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 25: // LD_RR C,(IX+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 26: // LD_RR D,(IX+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 27: // LD_RR E,(IX+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 28: // LD_RR H,(IX+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 29: // LD_RR L,(IX+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 30: // RR b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 31: // LD_RR A,(IX+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 32: // LD_SLA B,(IX+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 33: // LD_SLA C,(IX+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 34: // LD_SLA D,(IX+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 35: // LD_SLA E,(IX+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 36: // LD_SLA H,(IX+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 37: // LD_SLA L,(IX+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 38: // SLA b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 39: // LD_SLA A,(IX+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 40: // LD_SRA B,(IX+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 41: // LD_SRA C,(IX+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 42: // LD_SRA D,(IX+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 43: // LD_SRA E,(IX+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 44: // LD_SRA H,(IX+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 45: // LD_SRA L,(IX+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 46: // SRA b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 47: // LD_SRA A,(IX+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 48: // LD_SLL B,(IX+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 49: // LD_SLL C,(IX+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 50: // LD_SLL D,(IX+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 51: // LD_SLL E,(IX+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 52: // LD_SLL H,(IX+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 53: // LD_SLL L,(IX+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 54: // SLL b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 55: // LD_SLL A,(IX+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 56: // LD_SRL B,(IX+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 57: // LD_SRL C,(IX+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 58: // LD_SRL D,(IX+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 59: // LD_SRL E,(IX+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 60: // LD_SRL H,(IX+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 61: // LD_SRL L,(IX+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 62: // SRL b(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 63: // LD_SRL A,(IX+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		return (19);
+	break;
+	case 64: // BIT 0,(IX+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 65: // BIT 0,(IX+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 66: // BIT 0,(IX+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 67: // BIT 0,(IX+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 68: // BIT 0,(IX+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 69: // BIT 0,(IX+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 70: // BIT 0,(IX+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 71: // BIT 0,(IX+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 72: // BIT 1,(IX+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 73: // BIT 1,(IX+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 74: // BIT 1,(IX+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 75: // BIT 1,(IX+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 76: // BIT 1,(IX+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 77: // BIT 1,(IX+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 78: // BIT 1,(IX+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 79: // BIT 1,(IX+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 80: // BIT 2,(IX+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 81: // BIT 2,(IX+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 82: // BIT 2,(IX+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 83: // BIT 2,(IX+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 84: // BIT 2,(IX+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 85: // BIT 2,(IX+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 86: // BIT 2,(IX+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 87: // BIT 2,(IX+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 88: // BIT 3,(IX+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 89: // BIT 3,(IX+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 90: // BIT 3,(IX+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 91: // BIT 3,(IX+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 92: // BIT 3,(IX+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 93: // BIT 3,(IX+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 94: // BIT 3,(IX+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 95: // BIT 3,(IX+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 96: // BIT 4,(IX+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 97: // BIT 4,(IX+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 98: // BIT 4,(IX+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 99: // BIT 4,(IX+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 100: // BIT 4,(IX+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 101: // BIT 4,(IX+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 102: // BIT 4,(IX+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 103: // BIT 4,(IX+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 104: // BIT 5,(IX+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 105: // BIT 5,(IX+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 106: // BIT 5,(IX+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 107: // BIT 5,(IX+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 108: // BIT 5,(IX+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 109: // BIT 5,(IX+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 110: // BIT 5,(IX+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 111: // BIT 5,(IX+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 112: // BIT 6,(IX+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 113: // BIT 6,(IX+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 114: // BIT 6,(IX+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 115: // BIT 6,(IX+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 116: // BIT 6,(IX+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 117: // BIT 6,(IX+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 118: // BIT 6,(IX+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 119: // BIT 6,(IX+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 120: // BIT 7,(IX+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 121: // BIT 7,(IX+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 122: // BIT 7,(IX+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 123: // BIT 7,(IX+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 124: // BIT 7,(IX+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 125: // BIT 7,(IX+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 126: // BIT 7,(IX+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 127: // BIT 7,(IX+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		return (16);
+	break;
+	case 128: // LD_RES B,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 129: // LD_RES C,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 130: // LD_RES D,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 131: // LD_RES E,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 132: // LD_RES H,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 133: // LD_RES L,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 134: // RES 0,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 135: // LD_RES A,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 136: // LD_RES B,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 137: // LD_RES C,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 138: // LD_RES D,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 139: // LD_RES E,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 140: // LD_RES H,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 141: // LD_RES L,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 142: // RES 1,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 143: // LD_RES A,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 144: // LD_RES B,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 145: // LD_RES C,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 146: // LD_RES D,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 147: // LD_RES E,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 148: // LD_RES H,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 149: // LD_RES L,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 150: // RES 2,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 151: // LD_RES A,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 152: // LD_RES B,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 153: // LD_RES C,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 154: // LD_RES D,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 155: // LD_RES E,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 156: // LD_RES H,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 157: // LD_RES L,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 158: // RES 3,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 159: // LD_RES A,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 160: // LD_RES B,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 161: // LD_RES C,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 162: // LD_RES D,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 163: // LD_RES E,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 164: // LD_RES H,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 165: // LD_RES L,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 166: // RES 4,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 167: // LD_RES A,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 168: // LD_RES B,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 169: // LD_RES C,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 170: // LD_RES D,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 171: // LD_RES E,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 172: // LD_RES H,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 173: // LD_RES L,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 174: // RES 5,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 175: // LD_RES A,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 176: // LD_RES B,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 177: // LD_RES C,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 178: // LD_RES D,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 179: // LD_RES E,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 180: // LD_RES H,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 181: // LD_RES L,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 182: // RES 6,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 183: // LD_RES A,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 184: // LD_RES B,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 185: // LD_RES C,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 186: // LD_RES D,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 187: // LD_RES E,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 188: // LD_RES H,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 189: // LD_RES L,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 190: // RES 7,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 191: // LD_RES A,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 192: // LD_SET B,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 193: // LD_SET C,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 194: // LD_SET D,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 195: // LD_SET E,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 196: // LD_SET H,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 197: // LD_SET L,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 198: // SET 0,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 199: // LD_SET A,0,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 200: // LD_SET B,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 201: // LD_SET C,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 202: // LD_SET D,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 203: // LD_SET E,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 204: // LD_SET H,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 205: // LD_SET L,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 206: // SET 1,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 207: // LD_SET A,1,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 208: // LD_SET B,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 209: // LD_SET C,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 210: // LD_SET D,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 211: // LD_SET E,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 212: // LD_SET H,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 213: // LD_SET L,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 214: // SET 2,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 215: // LD_SET A,2,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 216: // LD_SET B,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 217: // LD_SET C,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 218: // LD_SET D,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 219: // LD_SET E,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 220: // LD_SET H,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 221: // LD_SET L,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 222: // SET 3,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 223: // LD_SET A,3,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 224: // LD_SET B,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 225: // LD_SET C,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 226: // LD_SET D,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 227: // LD_SET E,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 228: // LD_SET H,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 229: // LD_SET L,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 230: // SET 4,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 231: // LD_SET A,4,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 232: // LD_SET B,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 233: // LD_SET C,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 234: // LD_SET D,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 235: // LD_SET E,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 236: // LD_SET H,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 237: // LD_SET L,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 238: // SET 5,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 239: // LD_SET A,5,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 240: // LD_SET B,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 241: // LD_SET C,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 242: // LD_SET D,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 243: // LD_SET E,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 244: // LD_SET H,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 245: // LD_SET L,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 246: // SET 6,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 247: // LD_SET A,6,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 248: // LD_SET B,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 249: // LD_SET C,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 250: // LD_SET D,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 251: // LD_SET E,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 252: // LD_SET H,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 253: // LD_SET L,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 254: // SET 7,(IX+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1))));
+		return (19);
+	break;
+	case 255: // LD_SET A,7,(IX+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IX,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	}
+
+	return -1;
+}
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free_codesED.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesED.c
--- fuse-1.6.0/peripherals/disk/z80free/Z80free_codesED.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesED.c	2023-08-07 09:56:42.531706621 +0200
@@ -0,0 +1,1098 @@
+/*
+ * Copyright (C) 2008-2009 Sergio Costas (Raster Software Vigo)
+ * This file is part of Z80Free
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ */
+
+#include "Z80free.h"
+
+int Z80free_codesED (Z80FREE *processor,byte opcode) {
+	static byte tmp1;
+	static byte tmp2;
+	static word tmp3;
+
+	switch(opcode) {
+	case 0: // NOP
+		return (4);
+	break;
+	case 1: // NOP
+		return (4);
+	break;
+	case 2: // NOP
+		return (4);
+	break;
+	case 3: // NOP
+		return (4);
+	break;
+	case 4: // NOP
+		return (4);
+	break;
+	case 5: // NOP
+		return (4);
+	break;
+	case 6: // NOP
+		return (4);
+	break;
+	case 7: // NOP
+		return (4);
+	break;
+	case 8: // NOP
+		return (4);
+	break;
+	case 9: // NOP
+		return (4);
+	break;
+	case 10: // NOP
+		return (4);
+	break;
+	case 11: // NOP
+		return (4);
+	break;
+	case 12: // NOP
+		return (4);
+	break;
+	case 13: // NOP
+		return (4);
+	break;
+	case 14: // NOP
+		return (4);
+	break;
+	case 15: // NOP
+		return (4);
+	break;
+	case 16: // NOP
+		return (4);
+	break;
+	case 17: // NOP
+		return (4);
+	break;
+	case 18: // NOP
+		return (4);
+	break;
+	case 19: // NOP
+		return (4);
+	break;
+	case 20: // NOP
+		return (4);
+	break;
+	case 21: // NOP
+		return (4);
+	break;
+	case 22: // NOP
+		return (4);
+	break;
+	case 23: // NOP
+		return (4);
+	break;
+	case 24: // NOP
+		return (4);
+	break;
+	case 25: // NOP
+		return (4);
+	break;
+	case 26: // NOP
+		return (4);
+	break;
+	case 27: // NOP
+		return (4);
+	break;
+	case 28: // NOP
+		return (4);
+	break;
+	case 29: // NOP
+		return (4);
+	break;
+	case 30: // NOP
+		return (4);
+	break;
+	case 31: // NOP
+		return (4);
+	break;
+	case 32: // NOP
+		return (4);
+	break;
+	case 33: // NOP
+		return (4);
+	break;
+	case 34: // NOP
+		return (4);
+	break;
+	case 35: // NOP
+		return (4);
+	break;
+	case 36: // NOP
+		return (4);
+	break;
+	case 37: // NOP
+		return (4);
+	break;
+	case 38: // NOP
+		return (4);
+	break;
+	case 39: // NOP
+		return (4);
+	break;
+	case 40: // NOP
+		return (4);
+	break;
+	case 41: // NOP
+		return (4);
+	break;
+	case 42: // NOP
+		return (4);
+	break;
+	case 43: // NOP
+		return (4);
+	break;
+	case 44: // NOP
+		return (4);
+	break;
+	case 45: // NOP
+		return (4);
+	break;
+	case 46: // NOP
+		return (4);
+	break;
+	case 47: // NOP
+		return (4);
+	break;
+	case 48: // NOP
+		return (4);
+	break;
+	case 49: // NOP
+		return (4);
+	break;
+	case 50: // NOP
+		return (4);
+	break;
+	case 51: // NOP
+		return (4);
+	break;
+	case 52: // NOP
+		return (4);
+	break;
+	case 53: // NOP
+		return (4);
+	break;
+	case 54: // NOP
+		return (4);
+	break;
+	case 55: // NOP
+		return (4);
+	break;
+	case 56: // NOP
+		return (4);
+	break;
+	case 57: // NOP
+		return (4);
+	break;
+	case 58: // NOP
+		return (4);
+	break;
+	case 59: // NOP
+		return (4);
+	break;
+	case 60: // NOP
+		return (4);
+	break;
+	case 61: // NOP
+		return (4);
+	break;
+	case 62: // NOP
+		return (4);
+	break;
+	case 63: // NOP
+		return (4);
+	break;
+	case 64: // IN_BC B
+		processor->Rm.br.B=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_adjustFlagSZP (processor,processor->Rm.br.B);
+		Z80free_resFlag(processor,F_H|F_N);
+		Z80free_adjustFlags (processor, processor->Rm.br.B);
+		return (8);
+	break;
+	case 65: // OUT_BC B
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,processor->Rm.br.B);
+		return (8);
+	break;
+	case 66: // SBC HL,BC
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.BC,1,1);
+		return (11);
+	break;
+	case 67: // LD (nn),BC
+		Z80free_write16(processor, Z80free_read_param_16(processor),processor->Rm.wr.BC);
+		return (16);
+	break;
+	case 68: // NEG
+		processor->Rm.br.A=Z80free_doArithmetic(processor,0,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 69: // RETN
+		processor->IFF1=processor->IFF2;
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 70: // IM 0
+		processor->IM=0;
+		return (4);
+	break;
+	case 71: // LD I,A
+		processor->I=processor->Rm.br.A;
+		return (5);
+	break;
+	case 72: // IN_BC C
+		processor->Rm.br.C=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_adjustFlagSZP (processor,processor->Rm.br.C);
+		Z80free_resFlag(processor,F_H|F_N);
+		Z80free_adjustFlags (processor, processor->Rm.br.C);
+		return (8);
+	break;
+	case 73: // OUT_BC C
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,processor->Rm.br.C);
+		return (8);
+	break;
+	case 74: // ADC HL,BC
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.BC,1,0);
+		return (11);
+	break;
+	case 75: // LD BC,(nn)
+		processor->Rm.wr.BC=Z80free_read16(processor, Z80free_read_param_16(processor));
+		return (16);
+	break;
+	case 76: // NEG
+		processor->Rm.br.A=Z80free_doArithmetic(processor,0,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 77: // RETI
+		processor->IFF1=processor->IFF2;
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 78: // IM 0
+		processor->IM=0;
+		return (4);
+	break;
+	case 79: // LD R,A
+		Z80free_setR(processor,processor->Rm.br.A);
+		return (5);
+	break;
+	case 80: // IN_BC D
+		processor->Rm.br.D=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_adjustFlagSZP (processor,processor->Rm.br.D);
+		Z80free_resFlag(processor,F_H|F_N);
+		Z80free_adjustFlags (processor, processor->Rm.br.D);
+		return (8);
+	break;
+	case 81: // OUT_BC D
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,processor->Rm.br.D);
+		return (8);
+	break;
+	case 82: // SBC HL,DE
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.DE,1,1);
+		return (11);
+	break;
+	case 83: // LD (nn),DE
+		Z80free_write16(processor, Z80free_read_param_16(processor),processor->Rm.wr.DE);
+		return (16);
+	break;
+	case 84: // NEG
+		processor->Rm.br.A=Z80free_doArithmetic(processor,0,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 85: // RETN
+		processor->IFF1=processor->IFF2;
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 86: // IM 1
+		processor->IM=1;
+		return (4);
+	break;
+	case 87: // LD A,I
+		processor->Rm.br.A=Z80free_readI(processor);
+		return (5);
+	break;
+	case 88: // IN_BC E
+		processor->Rm.br.E=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_adjustFlagSZP (processor,processor->Rm.br.E);
+		Z80free_resFlag(processor,F_H|F_N);
+		Z80free_adjustFlags (processor, processor->Rm.br.E);
+		return (8);
+	break;
+	case 89: // OUT_BC E
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,processor->Rm.br.E);
+		return (8);
+	break;
+	case 90: // ADC HL,DE
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.DE,1,0);
+		return (11);
+	break;
+	case 91: // LD DE,(nn)
+		processor->Rm.wr.DE=Z80free_read16(processor, Z80free_read_param_16(processor));
+		return (16);
+	break;
+	case 92: // NEG
+		processor->Rm.br.A=Z80free_doArithmetic(processor,0,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 93: // RETN
+		processor->IFF1=processor->IFF2;
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 94: // IM 2
+		processor->IM=2;
+		return (4);
+	break;
+	case 95: // LD A,R
+		processor->Rm.br.A=Z80free_readR(processor);
+		return (5);
+	break;
+	case 96: // IN_BC H
+		processor->Rm.br.H=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_adjustFlagSZP (processor,processor->Rm.br.H);
+		Z80free_resFlag(processor,F_H|F_N);
+		Z80free_adjustFlags (processor, processor->Rm.br.H);
+		return (8);
+	break;
+	case 97: // OUT_BC H
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,processor->Rm.br.H);
+		return (8);
+	break;
+	case 98: // SBC HL,HL
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.HL,1,1);
+		return (11);
+	break;
+	case 99: // LD (nn),HL
+		Z80free_write16(processor, Z80free_read_param_16(processor),processor->Rm.wr.HL);
+		return (16);
+	break;
+	case 100: // NEG
+		processor->Rm.br.A=Z80free_doArithmetic(processor,0,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 101: // RETN
+		processor->IFF1=processor->IFF2;
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 102: // IM 0
+		processor->IM=0;
+		return (4);
+	break;
+	case 103: // RRD
+		Z80free_doRRD(processor);
+		return (14);
+	break;
+	case 104: // IN_BC L
+		processor->Rm.br.L=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_adjustFlagSZP (processor,processor->Rm.br.L);
+		Z80free_resFlag(processor,F_H|F_N);
+		Z80free_adjustFlags (processor, processor->Rm.br.L);
+		return (8);
+	break;
+	case 105: // OUT_BC L
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,processor->Rm.br.L);
+		return (8);
+	break;
+	case 106: // ADC HL,HL
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.HL,1,0);
+		return (11);
+	break;
+	case 107: // LD HL,(nn)
+		processor->Rm.wr.HL=Z80free_read16(processor, Z80free_read_param_16(processor));
+		return (16);
+	break;
+	case 108: // NEG
+		processor->Rm.br.A=Z80free_doArithmetic(processor,0,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 109: // RETN
+		processor->IFF1=processor->IFF2;
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 110: // IM 0
+		processor->IM=0;
+		return (4);
+	break;
+	case 111: // RLD
+		Z80free_doRLD(processor);
+		return (14);
+	break;
+	case 112: // IN_BC
+		tmp1=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_adjustFlagSZP (processor,tmp1);
+		Z80free_resFlag(processor,F_H|F_N);
+		Z80free_adjustFlags (processor, tmp1);
+		return (8);
+	break;
+	case 113: // OUT_BC 0
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,0);
+		return (8);
+	break;
+	case 114: // SBC HL,SP
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.SP,1,1);
+		return (11);
+	break;
+	case 115: // LD (nn),SP
+		Z80free_write16(processor, Z80free_read_param_16(processor),processor->Rm.wr.SP);
+		return (16);
+	break;
+	case 116: // NEG
+		processor->Rm.br.A=Z80free_doArithmetic(processor,0,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 117: // RETN
+		processor->IFF1=processor->IFF2;
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 118: // IM 1
+		processor->IM=1;
+		return (4);
+	break;
+	case 119: // NOP
+		return (4);
+	break;
+	case 120: // IN_BC A
+		processor->Rm.br.A=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_adjustFlagSZP (processor,processor->Rm.br.A);
+		Z80free_resFlag(processor,F_H|F_N);
+		Z80free_adjustFlags (processor, processor->Rm.br.A);
+		return (8);
+	break;
+	case 121: // OUT_BC A
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,processor->Rm.br.A);
+		return (8);
+	break;
+	case 122: // ADC HL,SP
+		processor->Rm.wr.HL=Z80free_doArithmetic16(processor,processor->Rm.wr.HL,processor->Rm.wr.SP,1,0);
+		return (11);
+	break;
+	case 123: // LD SP,(nn)
+		processor->Rm.wr.SP=Z80free_read16(processor, Z80free_read_param_16(processor));
+		return (16);
+	break;
+	case 124: // NEG
+		processor->Rm.br.A=Z80free_doArithmetic(processor,0,processor->Rm.br.A,0,1);
+		return (4);
+	break;
+	case 125: // RETN
+		processor->IFF1=processor->IFF2;
+		processor->PC=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 126: // IM 2
+		processor->IM=2;
+		return (4);
+	break;
+	case 127: // NOP
+		return (4);
+	break;
+	case 128: // NOP
+		return (4);
+	break;
+	case 129: // NOP
+		return (4);
+	break;
+	case 130: // NOP
+		return (4);
+	break;
+	case 131: // NOP
+		return (4);
+	break;
+	case 132: // NOP
+		return (4);
+	break;
+	case 133: // NOP
+		return (4);
+	break;
+	case 134: // NOP
+		return (4);
+	break;
+	case 135: // NOP
+		return (4);
+	break;
+	case 136: // NOP
+		return (4);
+	break;
+	case 137: // NOP
+		return (4);
+	break;
+	case 138: // NOP
+		return (4);
+	break;
+	case 139: // NOP
+		return (4);
+	break;
+	case 140: // NOP
+		return (4);
+	break;
+	case 141: // NOP
+		return (4);
+	break;
+	case 142: // NOP
+		return (4);
+	break;
+	case 143: // NOP
+		return (4);
+	break;
+	case 144: // NOP
+		return (4);
+	break;
+	case 145: // NOP
+		return (4);
+	break;
+	case 146: // NOP
+		return (4);
+	break;
+	case 147: // NOP
+		return (4);
+	break;
+	case 148: // NOP
+		return (4);
+	break;
+	case 149: // NOP
+		return (4);
+	break;
+	case 150: // NOP
+		return (4);
+	break;
+	case 151: // NOP
+		return (4);
+	break;
+	case 152: // NOP
+		return (4);
+	break;
+	case 153: // NOP
+		return (4);
+	break;
+	case 154: // NOP
+		return (4);
+	break;
+	case 155: // NOP
+		return (4);
+	break;
+	case 156: // NOP
+		return (4);
+	break;
+	case 157: // NOP
+		return (4);
+	break;
+	case 158: // NOP
+		return (4);
+	break;
+	case 159: // NOP
+		return (4);
+	break;
+	case 160: // LDI
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL++);
+		Z80free_Wr_Internal(processor,processor->Rm.wr.DE++,tmp1);
+		tmp1+=processor->Rm.br.A;
+		Z80free_valFlag(processor,F_3,tmp1&0x08);
+		Z80free_valFlag(processor,F_5,tmp1&0x02);
+		processor->Rm.wr.BC--;
+		Z80free_resFlag(processor,F_H|F_N);
+		if (processor->Rm.wr.BC)
+			Z80free_setFlag(processor,F_PV);
+		else
+			Z80free_resFlag(processor,F_PV);
+		return (12);
+	break;
+	case 161: // CPI
+		tmp2=F_C&processor->Rm.br.F;
+		tmp1=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,processor->Rm.wr.HL++),0,1);
+		if (processor->Rm.br.F&F_H)
+			tmp1--;
+		Z80free_valFlag(processor,F_3,tmp1&0x08);
+		Z80free_valFlag(processor,F_5,tmp1&0x02);
+		Z80free_setFlag(processor,F_N);
+		Z80free_valFlag(processor,F_C,tmp2);
+		processor->Rm.wr.BC--;
+		if (processor->Rm.wr.BC)
+			Z80free_setFlag(processor,F_PV);
+		else
+			Z80free_resFlag(processor,F_PV);
+		return (12);
+	break;
+	case 162: // INI
+		/*INI, IND, INIR and INDR first decrement B and then uses it*/
+		tmp1=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,tmp1);
+		processor->Rm.wr.HL++;
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		Z80free_valFlag(processor,F_N,((tmp1&0x80)!=0));
+		tmp3=((((word) processor->Rm.br.C)+1)&0xFF)+(word) tmp1;
+		Z80free_valFlag(processor,F_C,((tmp3&0x100)!=0));
+		Z80free_valFlag(processor,F_H,((tmp3&0x100)!=0));
+		Z80free_valFlag(processor,F_PV,(Z80free_parityBit[(((byte)tmp3)&0x07)^processor->Rm.br.B]));
+		Z80free_valFlag(processor,F_Z, (processor->Rm.br.B == 0));
+		return (12);
+	break;
+	case 163: // OUTI
+		/*OUTI, OUTD, OTIR and OTDR first decrements B and then uses it*/
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,tmp1);
+		processor->Rm.wr.HL++;
+		Z80free_valFlag(processor,F_N,((tmp1&0x80)!=0));
+		tmp3=(word) processor->Rm.br.L+(word)tmp1;
+		Z80free_valFlag(processor,F_C,((tmp3&0x100)!=0));
+		Z80free_valFlag(processor,F_H,((tmp3&0x100)!=0));
+		Z80free_valFlag(processor,F_PV,(Z80free_parityBit[(((byte)tmp3)&0x07)^processor->Rm.br.B]));
+		return (12);
+	break;
+	case 164: // NOP
+		return (4);
+	break;
+	case 165: // NOP
+		return (4);
+	break;
+	case 166: // NOP
+		return (4);
+	break;
+	case 167: // NOP
+		return (4);
+	break;
+	case 168: // LDD
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL--);
+		Z80free_Wr_Internal(processor,processor->Rm.wr.DE--,tmp1);
+		tmp1+=processor->Rm.br.A;
+		Z80free_valFlag(processor,F_3,tmp1&0x08);
+		Z80free_valFlag(processor,F_5,tmp1&0x02);
+		processor->Rm.wr.BC--;
+		Z80free_resFlag(processor,F_H|F_N);
+		if (processor->Rm.wr.BC)
+			Z80free_setFlag(processor,F_PV);
+		else
+			Z80free_resFlag(processor,F_PV);
+		return (12);
+	break;
+	case 169: // CPD
+		tmp2=F_C&processor->Rm.br.F;
+		tmp1=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,processor->Rm.wr.HL--),0,1);
+		if (processor->Rm.br.F&F_H)
+			tmp1--;
+		Z80free_valFlag(processor,F_3,tmp1&0x08);
+		Z80free_valFlag(processor,F_5,tmp1&0x02);
+		Z80free_setFlag(processor,F_N);
+		Z80free_valFlag(processor,F_C,tmp2);
+		processor->Rm.wr.BC--;
+		if (processor->Rm.wr.BC)
+			Z80free_setFlag(processor,F_PV);
+		else
+			Z80free_resFlag(processor,F_PV);
+		return (12);
+	break;
+	case 170: // IND
+		tmp1=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,tmp1);
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		processor->Rm.wr.HL--;
+		Z80free_valFlag(processor,F_N,((tmp1&0x80)!=0));
+		tmp3=((((word) processor->Rm.br.C)-1)&0xFF)+(word) tmp1;
+		Z80free_valFlag(processor,F_C,((tmp3&0x100)!=0));
+		Z80free_valFlag(processor,F_H,((tmp3&0x100)!=0));
+		Z80free_valFlag(processor,F_PV,(Z80free_parityBit[(((byte)tmp3)&0x07)^processor->Rm.br.B]));
+		return (12);
+	break;
+	case 171: // OUTD
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,tmp1);
+		processor->Rm.wr.HL--;
+		Z80free_valFlag(processor,F_N,((tmp1&0x80)!=0));
+		tmp3=(word) processor->Rm.br.L+(word)tmp1;
+		Z80free_valFlag(processor,F_C,((tmp3&0x100)!=0));
+		Z80free_valFlag(processor,F_H,((tmp3&0x100)!=0));
+		Z80free_valFlag(processor,F_PV,(Z80free_parityBit[(((byte)tmp3)&0x07)^processor->Rm.br.B]));
+		return (12);
+	break;
+	case 172: // NOP
+		return (4);
+	break;
+	case 173: // NOP
+		return (4);
+	break;
+	case 174: // NOP
+		return (4);
+	break;
+	case 175: // NOP
+		return (4);
+	break;
+	case 176: // LDIR
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL++);
+		Z80free_Wr_Internal(processor,processor->Rm.wr.DE++,tmp1);
+		processor->Rm.wr.BC--;
+		if (processor->Rm.wr.BC) {
+			processor->PC-=2;
+			return (17);
+		} else {
+			Z80free_resFlag(processor,F_H|F_N|F_PV);
+		tmp1+=processor->Rm.br.A;
+		Z80free_valFlag(processor,F_3,tmp1&0x08);
+		Z80free_valFlag(processor,F_5,tmp1&0x02);
+			return (12);
+		}
+	break;
+	case 177: // CPIR
+		tmp2=F_C&processor->Rm.br.F;
+		tmp1=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,processor->Rm.wr.HL++),0,1);
+		processor->Rm.wr.BC--;
+		if ((processor->Rm.wr.BC)&&(!(processor->Rm.br.F&F_Z))) {
+			processor->PC-=2;
+			Z80free_valFlag(processor,F_C,tmp2);
+			return (17);
+		} else {
+			//Bit3 and bit 5 are set only at the end of the loop to save cpu time
+			if (processor->Rm.br.F&F_H)
+				tmp1--;
+			Z80free_valFlag(processor,F_3,tmp1&0x08);
+			Z80free_valFlag(processor,F_5,tmp1&0x02);
+			Z80free_resFlag(processor,F_PV);
+			Z80free_setFlag(processor,F_N);
+			Z80free_valFlag(processor,F_C,tmp2);
+			if (processor->Rm.wr.BC)
+				Z80free_setFlag(processor,F_PV);
+			return (12);
+		}
+	break;
+	case 178: // INIR
+		tmp1=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,tmp1);
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		processor->Rm.wr.HL++;
+		if (processor->Rm.br.B) {
+			processor->PC-=2;
+			return (17);
+		} else {
+			Z80free_valFlag(processor,F_N,((tmp1&0x80)!=0));
+			tmp3=((((word) processor->Rm.br.C)+1)&0xFF)+(word) tmp1;
+			Z80free_valFlag(processor,F_C,((tmp3&0x100)!=0));
+			Z80free_valFlag(processor,F_H,((tmp3&0x100)!=0));
+			Z80free_valFlag(processor,F_PV,(Z80free_parityBit[(((byte)tmp3)&0x07)^processor->Rm.br.B]));
+			return (12);
+		}
+	break;
+	case 179: // OTIR
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,tmp1);
+		processor->Rm.wr.HL++;
+		if (processor->Rm.br.B) {
+			processor->PC-=2;
+			return (17);
+		} else {
+			Z80free_valFlag(processor,F_N,((tmp1&0x80)!=0));
+			tmp3=(word) processor->Rm.br.L+(word)tmp1;
+			Z80free_valFlag(processor,F_C,((tmp3&0x100)!=0));
+			Z80free_valFlag(processor,F_H,((tmp3&0x100)!=0));
+			Z80free_valFlag(processor,F_PV,(Z80free_parityBit[(((byte)tmp3)&0x07)^processor->Rm.br.B]));
+			return (12);
+		}
+	break;
+	case 180: // NOP
+		return (4);
+	break;
+	case 181: // NOP
+		return (4);
+	break;
+	case 182: // NOP
+		return (4);
+	break;
+	case 183: // NOP
+		return (4);
+	break;
+	case 184: // LDDR
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL--);
+		Z80free_Wr_Internal(processor,processor->Rm.wr.DE--,tmp1);
+		processor->Rm.wr.BC--;
+		if (processor->Rm.wr.BC) {
+			processor->PC-=2;
+			return (17);
+		} else {
+			Z80free_resFlag(processor,F_H|F_N|F_PV);
+		tmp1+=processor->Rm.br.A;
+		Z80free_valFlag(processor,F_3,tmp1&0x08);
+		Z80free_valFlag(processor,F_5,tmp1&0x02);
+			return (12);
+		}
+	break;
+	case 185: // CPDR
+		tmp2=F_C&processor->Rm.br.F;
+		tmp1=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,processor->Rm.wr.HL--),0,1);
+		processor->Rm.wr.BC--;
+		if ((processor->Rm.wr.BC)&&(!(processor->Rm.br.F&F_Z))) {
+			processor->PC-=2;
+			Z80free_valFlag(processor,F_C,tmp2);
+			return (17);
+		} else {
+			//Bit3 and bit 5 are set only at the end of the loop to save cpu time
+			if (processor->Rm.br.F&F_H)
+				tmp1--;
+			Z80free_valFlag(processor,F_3,tmp1&0x08);
+			Z80free_valFlag(processor,F_5,tmp1&0x02);
+			Z80free_resFlag(processor,F_PV);
+			Z80free_setFlag(processor,F_N);
+			Z80free_valFlag(processor,F_C,tmp2);
+			if (processor->Rm.wr.BC)
+				Z80free_setFlag(processor,F_PV);
+			return (12);
+		}
+	break;
+	case 186: // INDR
+		tmp1=Z80free_In_Internal(processor,processor->Rm.wr.BC);
+		Z80free_Wr_Internal(processor,processor->Rm.wr.HL,tmp1);
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		processor->Rm.wr.HL--;
+		if (processor->Rm.br.B) {
+			processor->PC-=2;
+			return (17);
+		} else {
+			Z80free_valFlag(processor,F_N,((tmp1&0x80)!=0));
+			tmp3=((((word) processor->Rm.br.C)-1)&0xFF)+(word) tmp1;
+			Z80free_valFlag(processor,F_C,((tmp3&0x100)!=0));
+			Z80free_valFlag(processor,F_H,((tmp3&0x100)!=0));
+			Z80free_valFlag(processor,F_PV,(Z80free_parityBit[(((byte)tmp3)&0x07)^processor->Rm.br.B]));
+			return (12);
+		}
+	break;
+	case 187: // OTDR
+		processor->Rm.br.B=Z80free_doIncDec(processor,processor->Rm.br.B,1);
+		tmp1=Z80free_Rd_Internal(processor,processor->Rm.wr.HL);
+		Z80free_Out_Internal(processor,processor->Rm.wr.BC,tmp1);
+		processor->Rm.wr.HL--;
+		if (processor->Rm.br.B) {
+			processor->PC-=2;
+			return (17);
+		} else {
+			Z80free_valFlag(processor,F_N,((tmp1&0x80)!=0));
+			tmp3=(word) processor->Rm.br.L+(word)tmp1;
+			Z80free_valFlag(processor,F_C,((tmp3&0x100)!=0));
+			Z80free_valFlag(processor,F_H,((tmp3&0x100)!=0));
+			Z80free_valFlag(processor,F_PV,(Z80free_parityBit[(((byte)tmp3)&0x07)^processor->Rm.br.B]));
+			return (12);
+		}
+	break;
+	case 188: // NOP
+		return (4);
+	break;
+	case 189: // NOP
+		return (4);
+	break;
+	case 190: // NOP
+		return (4);
+	break;
+	case 191: // NOP
+		return (4);
+	break;
+	case 192: // NOP
+		return (4);
+	break;
+	case 193: // NOP
+		return (4);
+	break;
+	case 194: // NOP
+		return (4);
+	break;
+	case 195: // NOP
+		return (4);
+	break;
+	case 196: // NOP
+		return (4);
+	break;
+	case 197: // NOP
+		return (4);
+	break;
+	case 198: // NOP
+		return (4);
+	break;
+	case 199: // NOP
+		return (4);
+	break;
+	case 200: // NOP
+		return (4);
+	break;
+	case 201: // NOP
+		return (4);
+	break;
+	case 202: // NOP
+		return (4);
+	break;
+	case 203: // NOP
+		return (4);
+	break;
+	case 204: // NOP
+		return (4);
+	break;
+	case 205: // NOP
+		return (4);
+	break;
+	case 206: // NOP
+		return (4);
+	break;
+	case 207: // NOP
+		return (4);
+	break;
+	case 208: // NOP
+		return (4);
+	break;
+	case 209: // NOP
+		return (4);
+	break;
+	case 210: // NOP
+		return (4);
+	break;
+	case 211: // NOP
+		return (4);
+	break;
+	case 212: // NOP
+		return (4);
+	break;
+	case 213: // NOP
+		return (4);
+	break;
+	case 214: // NOP
+		return (4);
+	break;
+	case 215: // NOP
+		return (4);
+	break;
+	case 216: // NOP
+		return (4);
+	break;
+	case 217: // NOP
+		return (4);
+	break;
+	case 218: // NOP
+		return (4);
+	break;
+	case 219: // NOP
+		return (4);
+	break;
+	case 220: // NOP
+		return (4);
+	break;
+	case 221: // NOP
+		return (4);
+	break;
+	case 222: // NOP
+		return (4);
+	break;
+	case 223: // NOP
+		return (4);
+	break;
+	case 224: // NOP
+		return (4);
+	break;
+	case 225: // NOP
+		return (4);
+	break;
+	case 226: // NOP
+		return (4);
+	break;
+	case 227: // NOP
+		return (4);
+	break;
+	case 228: // NOP
+		return (4);
+	break;
+	case 229: // NOP
+		return (4);
+	break;
+	case 230: // NOP
+		return (4);
+	break;
+	case 231: // NOP
+		return (4);
+	break;
+	case 232: // NOP
+		return (4);
+	break;
+	case 233: // NOP
+		return (4);
+	break;
+	case 234: // NOP
+		return (4);
+	break;
+	case 235: // NOP
+		return (4);
+	break;
+	case 236: // NOP
+		return (4);
+	break;
+	case 237: // NOP
+		return (4);
+	break;
+	case 238: // NOP
+		return (4);
+	break;
+	case 239: // NOP
+		return (4);
+	break;
+	case 240: // NOP
+		return (4);
+	break;
+	case 241: // NOP
+		return (4);
+	break;
+	case 242: // NOP
+		return (4);
+	break;
+	case 243: // NOP
+		return (4);
+	break;
+	case 244: // NOP
+		return (4);
+	break;
+	case 245: // NOP
+		return (4);
+	break;
+	case 246: // NOP
+		return (4);
+	break;
+	case 247: // NOP
+		return (4);
+	break;
+	case 248: // NOP
+		return (4);
+	break;
+	case 249: // NOP
+		return (4);
+	break;
+	case 250: // NOP
+		return (4);
+	break;
+	case 251: // NOP
+		return (4);
+	break;
+	case 252: // NOP
+		return (4);
+	break;
+	case 253: // NOP
+		return (4);
+	break;
+	case 254: // NOP
+		return (4);
+	break;
+	case 255: // NOP
+		return (4);
+	break;
+	}
+
+	return -1;
+}
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free_codesFD.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesFD.c
--- fuse-1.6.0/peripherals/disk/z80free/Z80free_codesFD.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesFD.c	2023-08-07 09:56:42.535039966 +0200
@@ -0,0 +1,890 @@
+/*
+ * Copyright (C) 2008-2009 Sergio Costas (Raster Software Vigo)
+ * This file is part of Z80Free
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ */
+
+#include "Z80free.h"
+
+int Z80free_codesFD (Z80FREE *processor,byte opcode) {
+	static byte tmp1;
+	static word tmp2;
+
+	switch(opcode) {
+	case 0: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 1: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 2: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 3: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 4: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 5: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 6: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 7: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 8: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 9: // ADD IY,BC
+		processor->Rm.wr.IY=Z80free_doArithmetic16(processor,processor->Rm.wr.IY,processor->Rm.wr.BC,0,0);
+		return (11);
+	break;
+	case 10: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 11: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 12: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 13: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 14: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 15: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 16: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 17: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 18: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 19: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 20: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 21: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 22: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 23: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 24: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 25: // ADD IY,DE
+		processor->Rm.wr.IY=Z80free_doArithmetic16(processor,processor->Rm.wr.IY,processor->Rm.wr.DE,0,0);
+		return (11);
+	break;
+	case 26: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 27: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 28: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 29: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 30: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 31: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 32: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 33: // LD IY,nn
+		processor->Rm.wr.IY=Z80free_read_param_16(processor);
+		return (10);
+	break;
+	case 34: // LD (nn),IY
+		Z80free_write16(processor, Z80free_read_param_16(processor),processor->Rm.wr.IY);
+		return (16);
+	break;
+	case 35: // INC IY
+		processor->Rm.wr.IY=Z80free_doIncDec16(processor,processor->Rm.wr.IY,0);
+		return (6);
+	break;
+	case 36: // INC IYH
+		processor->Rm.br.IYh=Z80free_doIncDec(processor,processor->Rm.br.IYh,0);
+		return (4);
+	break;
+	case 37: // DEC IYH
+		processor->Rm.br.IYh=Z80free_doIncDec(processor,processor->Rm.br.IYh,1);
+		return (4);
+	break;
+	case 38: // LD IYH,n
+		processor->Rm.br.IYh=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 39: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 40: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 41: // ADD IY,IY
+		processor->Rm.wr.IY=Z80free_doArithmetic16(processor,processor->Rm.wr.IY,processor->Rm.wr.IY,0,0);
+		return (11);
+	break;
+	case 42: // LD IY,(nn)
+		processor->Rm.wr.IY=Z80free_read16(processor, Z80free_read_param_16(processor));
+		return (16);
+	break;
+	case 43: // DEC IY
+		processor->Rm.wr.IY=Z80free_doIncDec16(processor,processor->Rm.wr.IY,1);
+		return (6);
+	break;
+	case 44: // INC IYL
+		processor->Rm.br.IYl=Z80free_doIncDec(processor,processor->Rm.br.IYl,0);
+		return (4);
+	break;
+	case 45: // DEC IYL
+		processor->Rm.br.IYl=Z80free_doIncDec(processor,processor->Rm.br.IYl,1);
+		return (4);
+	break;
+	case 46: // LD IYL,n
+		processor->Rm.br.IYl=Z80free_read_param_8(processor);
+		return (7);
+	break;
+	case 47: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 48: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 49: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 50: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 51: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 52: // INC b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),Z80free_doIncDec(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)),0));
+		return (19);
+	break;
+	case 53: // DEC b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),Z80free_doIncDec(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)),1));
+		return (19);
+	break;
+	case 54: // LD2 IY+d,n
+		tmp2=Z80free_addr_relative(processor,processor->Rm.wr.IY);
+		Z80free_Wr_Internal(processor,tmp2,Z80free_read_param_8(processor));
+		return (15);
+	break;
+	case 55: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 56: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 57: // ADD IY,SP
+		processor->Rm.wr.IY=Z80free_doArithmetic16(processor,processor->Rm.wr.IY,processor->Rm.wr.SP,0,0);
+		return (11);
+	break;
+	case 58: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 59: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 60: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 61: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 62: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 63: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 64: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 65: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 66: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 67: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 68: // LD B,IYH
+		processor->Rm.br.B=processor->Rm.br.IYh;
+		return (4);
+	break;
+	case 69: // LD B,IYL
+		processor->Rm.br.B=processor->Rm.br.IYl;
+		return (4);
+	break;
+	case 70: // LD B,(IY+d)
+		processor->Rm.br.B=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY));
+		return (15);
+	break;
+	case 71: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 72: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 73: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 74: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 75: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 76: // LD C,IYH
+		processor->Rm.br.C=processor->Rm.br.IYh;
+		return (4);
+	break;
+	case 77: // LD C,IYL
+		processor->Rm.br.C=processor->Rm.br.IYl;
+		return (4);
+	break;
+	case 78: // LD C,(IY+d)
+		processor->Rm.br.C=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY));
+		return (15);
+	break;
+	case 79: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 80: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 81: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 82: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 83: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 84: // LD D,IYH
+		processor->Rm.br.D=processor->Rm.br.IYh;
+		return (4);
+	break;
+	case 85: // LD D,IYL
+		processor->Rm.br.D=processor->Rm.br.IYl;
+		return (4);
+	break;
+	case 86: // LD D,(IY+d)
+		processor->Rm.br.D=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY));
+		return (15);
+	break;
+	case 87: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 88: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 89: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 90: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 91: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 92: // LD E,IYH
+		processor->Rm.br.E=processor->Rm.br.IYh;
+		return (4);
+	break;
+	case 93: // LD E,IYL
+		processor->Rm.br.E=processor->Rm.br.IYl;
+		return (4);
+	break;
+	case 94: // LD E,(IY+d)
+		processor->Rm.br.E=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY));
+		return (15);
+	break;
+	case 95: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 96: // LD IYH,B
+		processor->Rm.br.IYh=processor->Rm.br.B;
+		return (4);
+	break;
+	case 97: // LD IYH,C
+		processor->Rm.br.IYh=processor->Rm.br.C;
+		return (4);
+	break;
+	case 98: // LD IYH,D
+		processor->Rm.br.IYh=processor->Rm.br.D;
+		return (4);
+	break;
+	case 99: // LD IYH,E
+		processor->Rm.br.IYh=processor->Rm.br.E;
+		return (4);
+	break;
+	case 100: // LD IYH,IYH
+		processor->Rm.br.IYh=processor->Rm.br.IYh;
+		return (4);
+	break;
+	case 101: // LD IYH,IYL
+		processor->Rm.br.IYh=processor->Rm.br.IYl;
+		return (4);
+	break;
+	case 102: // LD H,(IY+d)
+		processor->Rm.br.H=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY));
+		return (15);
+	break;
+	case 103: // LD IYH,A
+		processor->Rm.br.IYh=processor->Rm.br.A;
+		return (4);
+	break;
+	case 104: // LD IYL,B
+		processor->Rm.br.IYl=processor->Rm.br.B;
+		return (4);
+	break;
+	case 105: // LD IYL,C
+		processor->Rm.br.IYl=processor->Rm.br.C;
+		return (4);
+	break;
+	case 106: // LD IYL,D
+		processor->Rm.br.IYl=processor->Rm.br.D;
+		return (4);
+	break;
+	case 107: // LD IYL,E
+		processor->Rm.br.IYl=processor->Rm.br.E;
+		return (4);
+	break;
+	case 108: // LD IYL,IYH
+		processor->Rm.br.IYl=processor->Rm.br.IYh;
+		return (4);
+	break;
+	case 109: // LD IYL,IYL
+		processor->Rm.br.IYl=processor->Rm.br.IYl;
+		return (4);
+	break;
+	case 110: // LD L,(IY+d)
+		processor->Rm.br.L=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY));
+		return (15);
+	break;
+	case 111: // LD IYL,A
+		processor->Rm.br.IYl=processor->Rm.br.A;
+		return (4);
+	break;
+	case 112: // LD (IY+d),B
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),processor->Rm.br.B);
+		return (15);
+	break;
+	case 113: // LD (IY+d),C
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),processor->Rm.br.C);
+		return (15);
+	break;
+	case 114: // LD (IY+d),D
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),processor->Rm.br.D);
+		return (15);
+	break;
+	case 115: // LD (IY+d),E
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),processor->Rm.br.E);
+		return (15);
+	break;
+	case 116: // LD (IY+d),H
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),processor->Rm.br.H);
+		return (15);
+	break;
+	case 117: // LD (IY+d),L
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),processor->Rm.br.L);
+		return (15);
+	break;
+	case 118: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 119: // LD (IY+d),A
+		Z80free_Wr_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY),processor->Rm.br.A);
+		return (15);
+	break;
+	case 120: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 121: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 122: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 123: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 124: // LD A,IYH
+		processor->Rm.br.A=processor->Rm.br.IYh;
+		return (4);
+	break;
+	case 125: // LD A,IYL
+		processor->Rm.br.A=processor->Rm.br.IYl;
+		return (4);
+	break;
+	case 126: // LD A,(IY+d)
+		processor->Rm.br.A=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY));
+		return (15);
+	break;
+	case 127: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 128: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 129: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 130: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 131: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 132: // ADD A,IYH
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IYh,0,0);
+		return (4);
+	break;
+	case 133: // ADD A,IYL
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IYl,0,0);
+		return (4);
+	break;
+	case 134: // ADD A,(IY+d)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)),0,0);
+		return (15);
+	break;
+	case 135: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 136: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 137: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 138: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 139: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 140: // ADC A,IYH
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IYh,1,0);
+		return (4);
+	break;
+	case 141: // ADC A,IYL
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IYl,1,0);
+		return (4);
+	break;
+	case 142: // ADC A,(IY+d)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)),1,0);
+		return (15);
+	break;
+	case 143: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 144: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 145: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 146: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 147: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 148: // SUB IYH
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IYh,0,1);
+		return (4);
+	break;
+	case 149: // SUB IYL
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IYl,0,1);
+		return (4);
+	break;
+	case 150: // SUB b(IY+d)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)),0,1);
+		return (15);
+	break;
+	case 151: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 152: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 153: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 154: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 155: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 156: // SBC A,IYH
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IYh,1,1);
+		return (4);
+	break;
+	case 157: // SBC A,IYL
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,processor->Rm.br.IYl,1,1);
+		return (4);
+	break;
+	case 158: // SBC A,(IY+d)
+		processor->Rm.br.A=Z80free_doArithmetic(processor,processor->Rm.br.A,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)),1,1);
+		return (15);
+	break;
+	case 159: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 160: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 161: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 162: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 163: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 164: // AND IYH
+		Z80free_doAND(processor,processor->Rm.br.IYh);
+		return (4);
+	break;
+	case 165: // AND IYL
+		Z80free_doAND(processor,processor->Rm.br.IYl);
+		return (4);
+	break;
+	case 166: // AND b(IY+d)
+		Z80free_doAND(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)));
+		return (15);
+	break;
+	case 167: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 168: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 169: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 170: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 171: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 172: // XOR IYH
+		Z80free_doXOR(processor,processor->Rm.br.IYh);
+		return (4);
+	break;
+	case 173: // XOR IYL
+		Z80free_doXOR(processor,processor->Rm.br.IYl);
+		return (4);
+	break;
+	case 174: // XOR b(IY+d)
+		Z80free_doXOR(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)));
+		return (15);
+	break;
+	case 175: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 176: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 177: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 178: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 179: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 180: // OR IYH
+		Z80free_doOR(processor,processor->Rm.br.IYh);
+		return (4);
+	break;
+	case 181: // OR IYL
+		Z80free_doOR(processor,processor->Rm.br.IYl);
+		return (4);
+	break;
+	case 182: // OR b(IY+d)
+		Z80free_doOR(processor,Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY)));
+		return (15);
+	break;
+	case 183: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 184: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 185: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 186: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 187: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 188: // CP IYH
+		tmp1=processor->Rm.br.IYh;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 189: // CP IYL
+		tmp1=processor->Rm.br.IYl;
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (4);
+	break;
+	case 190: // CP b(IY+d)
+		tmp1=Z80free_Rd_Internal(processor,Z80free_addr_relative(processor,processor->Rm.wr.IY));
+		Z80free_doArithmetic(processor,processor->Rm.br.A,tmp1,0,1);
+		Z80free_adjustFlags(processor,tmp1);
+		return (15);
+	break;
+	case 191: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 192: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 193: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 194: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 195: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 196: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 197: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 198: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 199: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 200: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 201: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 202: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 204: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 205: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 206: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 207: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 208: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 209: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 210: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 211: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 212: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 213: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 214: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 215: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 216: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 217: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 218: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 219: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 220: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 221: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 222: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 223: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 224: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 225: // POP IY
+		processor->Rm.wr.IY=Z80free_doPop(processor);
+		return (10);
+	break;
+	case 226: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 227: // EX (SP),IY
+		tmp2=Z80free_read16(processor, processor->Rm.wr.SP);
+		Z80free_write16(processor, processor->Rm.wr.SP,processor->Rm.wr.IY);
+		processor->Rm.wr.IY=tmp2;
+		return (19);
+	break;
+	case 228: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 229: // PUSH IY
+		Z80free_doPush(processor,processor->Rm.wr.IY);
+		return (11);
+	break;
+	case 230: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 231: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 232: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 233: // JP IY
+		tmp2=processor->Rm.wr.IY;
+		processor->PC=tmp2;
+		return (4);
+	break;
+	case 234: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 235: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 236: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 237: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 238: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 239: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 240: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 241: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 242: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 243: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 244: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 245: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 246: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 247: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 248: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 249: // LD SP,IY
+		processor->Rm.wr.SP=processor->Rm.wr.IY;
+		return (6);
+	break;
+	case 250: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 251: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 252: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 253: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 254: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	case 255: // DEFAULT
+		return (Z80free_codes(processor,opcode));
+	break;
+	}
+
+	return -1;
+}
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free_codesFDCB.c fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesFDCB.c
--- fuse-1.6.0/peripherals/disk/z80free/Z80free_codesFDCB.c	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free_codesFDCB.c	2023-08-07 09:56:42.535039966 +0200
@@ -0,0 +1,1391 @@
+/*
+ * Copyright (C) 2008-2009 Sergio Costas (Raster Software Vigo)
+ * This file is part of Z80Free
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ */
+
+#include "Z80free.h"
+
+int Z80free_codesFDCB (Z80FREE *processor,byte d1) {
+	static byte tmp1;
+	static byte opcode;
+	opcode=Z80free_Rd_Internal(processor,processor->PC++);
+
+	switch(opcode) {
+	case 0: // LD_RLC B,(IY+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 1: // LD_RLC C,(IY+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 2: // LD_RLC D,(IY+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 3: // LD_RLC E,(IY+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 4: // LD_RLC H,(IY+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 5: // LD_RLC L,(IY+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 6: // RLC b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 7: // LD_RLC A,(IY+d)
+		tmp1=Z80free_doRLC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 8: // LD_RRC B,(IY+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 9: // LD_RRC C,(IY+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 10: // LD_RRC D,(IY+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 11: // LD_RRC E,(IY+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 12: // LD_RRC H,(IY+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 13: // LD_RRC L,(IY+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 14: // RRC b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 15: // LD_RRC A,(IY+d)
+		tmp1=Z80free_doRRC(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 16: // LD_RL B,(IY+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 17: // LD_RL C,(IY+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 18: // LD_RL D,(IY+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 19: // LD_RL E,(IY+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 20: // LD_RL H,(IY+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 21: // LD_RL L,(IY+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 22: // RL b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 23: // LD_RL A,(IY+d)
+		tmp1=Z80free_doRL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 24: // LD_RR B,(IY+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 25: // LD_RR C,(IY+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 26: // LD_RR D,(IY+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 27: // LD_RR E,(IY+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 28: // LD_RR H,(IY+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 29: // LD_RR L,(IY+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 30: // RR b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 31: // LD_RR A,(IY+d)
+		tmp1=Z80free_doRR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 32: // LD_SLA B,(IY+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 33: // LD_SLA C,(IY+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 34: // LD_SLA D,(IY+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 35: // LD_SLA E,(IY+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 36: // LD_SLA H,(IY+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 37: // LD_SLA L,(IY+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 38: // SLA b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 39: // LD_SLA A,(IY+d)
+		tmp1=Z80free_doSL(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 40: // LD_SRA B,(IY+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 41: // LD_SRA C,(IY+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 42: // LD_SRA D,(IY+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 43: // LD_SRA E,(IY+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 44: // LD_SRA H,(IY+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 45: // LD_SRA L,(IY+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 46: // SRA b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 47: // LD_SRA A,(IY+d)
+		tmp1=Z80free_doSR(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 48: // LD_SLL B,(IY+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 49: // LD_SLL C,(IY+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 50: // LD_SLL D,(IY+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 51: // LD_SLL E,(IY+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 52: // LD_SLL H,(IY+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 53: // LD_SLL L,(IY+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 54: // SLL b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 55: // LD_SLL A,(IY+d)
+		tmp1=Z80free_doSL(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 56: // LD_SRL B,(IY+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.B=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 57: // LD_SRL C,(IY+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.C=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 58: // LD_SRL D,(IY+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.D=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 59: // LD_SRL E,(IY+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.E=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 60: // LD_SRL H,(IY+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.H=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 61: // LD_SRL L,(IY+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.L=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 62: // SRL b(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 63: // LD_SRL A,(IY+d)
+		tmp1=Z80free_doSR(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		processor->Rm.br.A=tmp1;
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		return (19);
+	break;
+	case 64: // BIT 0,(IY+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 65: // BIT 0,(IY+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 66: // BIT 0,(IY+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 67: // BIT 0,(IY+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 68: // BIT 0,(IY+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 69: // BIT 0,(IY+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 70: // BIT 0,(IY+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 71: // BIT 0,(IY+d)
+		Z80free_doBIT(processor,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 72: // BIT 1,(IY+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 73: // BIT 1,(IY+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 74: // BIT 1,(IY+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 75: // BIT 1,(IY+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 76: // BIT 1,(IY+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 77: // BIT 1,(IY+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 78: // BIT 1,(IY+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 79: // BIT 1,(IY+d)
+		Z80free_doBIT(processor,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 80: // BIT 2,(IY+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 81: // BIT 2,(IY+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 82: // BIT 2,(IY+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 83: // BIT 2,(IY+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 84: // BIT 2,(IY+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 85: // BIT 2,(IY+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 86: // BIT 2,(IY+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 87: // BIT 2,(IY+d)
+		Z80free_doBIT(processor,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 88: // BIT 3,(IY+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 89: // BIT 3,(IY+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 90: // BIT 3,(IY+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 91: // BIT 3,(IY+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 92: // BIT 3,(IY+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 93: // BIT 3,(IY+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 94: // BIT 3,(IY+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 95: // BIT 3,(IY+d)
+		Z80free_doBIT(processor,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 96: // BIT 4,(IY+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 97: // BIT 4,(IY+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 98: // BIT 4,(IY+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 99: // BIT 4,(IY+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 100: // BIT 4,(IY+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 101: // BIT 4,(IY+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 102: // BIT 4,(IY+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 103: // BIT 4,(IY+d)
+		Z80free_doBIT(processor,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 104: // BIT 5,(IY+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 105: // BIT 5,(IY+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 106: // BIT 5,(IY+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 107: // BIT 5,(IY+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 108: // BIT 5,(IY+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 109: // BIT 5,(IY+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 110: // BIT 5,(IY+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 111: // BIT 5,(IY+d)
+		Z80free_doBIT(processor,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 112: // BIT 6,(IY+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 113: // BIT 6,(IY+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 114: // BIT 6,(IY+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 115: // BIT 6,(IY+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 116: // BIT 6,(IY+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 117: // BIT 6,(IY+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 118: // BIT 6,(IY+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 119: // BIT 6,(IY+d)
+		Z80free_doBIT(processor,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 120: // BIT 7,(IY+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 121: // BIT 7,(IY+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 122: // BIT 7,(IY+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 123: // BIT 7,(IY+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 124: // BIT 7,(IY+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 125: // BIT 7,(IY+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 126: // BIT 7,(IY+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 127: // BIT 7,(IY+d)
+		Z80free_doBIT(processor,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		return (16);
+	break;
+	case 128: // LD_RES B,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 129: // LD_RES C,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 130: // LD_RES D,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 131: // LD_RES E,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 132: // LD_RES H,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 133: // LD_RES L,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 134: // RES 0,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 135: // LD_RES A,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 136: // LD_RES B,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 137: // LD_RES C,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 138: // LD_RES D,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 139: // LD_RES E,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 140: // LD_RES H,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 141: // LD_RES L,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 142: // RES 1,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 143: // LD_RES A,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 144: // LD_RES B,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 145: // LD_RES C,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 146: // LD_RES D,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 147: // LD_RES E,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 148: // LD_RES H,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 149: // LD_RES L,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 150: // RES 2,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 151: // LD_RES A,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 152: // LD_RES B,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 153: // LD_RES C,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 154: // LD_RES D,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 155: // LD_RES E,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 156: // LD_RES H,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 157: // LD_RES L,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 158: // RES 3,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 159: // LD_RES A,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 160: // LD_RES B,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 161: // LD_RES C,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 162: // LD_RES D,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 163: // LD_RES E,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 164: // LD_RES H,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 165: // LD_RES L,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 166: // RES 4,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 167: // LD_RES A,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 168: // LD_RES B,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 169: // LD_RES C,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 170: // LD_RES D,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 171: // LD_RES E,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 172: // LD_RES H,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 173: // LD_RES L,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 174: // RES 5,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 175: // LD_RES A,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 176: // LD_RES B,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 177: // LD_RES C,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 178: // LD_RES D,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 179: // LD_RES E,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 180: // LD_RES H,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 181: // LD_RES L,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 182: // RES 6,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 183: // LD_RES A,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 184: // LD_RES B,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 185: // LD_RES C,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 186: // LD_RES D,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 187: // LD_RES E,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 188: // LD_RES H,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 189: // LD_RES L,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 190: // RES 7,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 191: // LD_RES A,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,0,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 192: // LD_SET B,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 193: // LD_SET C,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 194: // LD_SET D,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 195: // LD_SET E,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 196: // LD_SET H,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 197: // LD_SET L,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 198: // SET 0,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 199: // LD_SET A,0,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,0,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 200: // LD_SET B,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 201: // LD_SET C,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 202: // LD_SET D,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 203: // LD_SET E,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 204: // LD_SET H,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 205: // LD_SET L,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 206: // SET 1,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 207: // LD_SET A,1,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,1,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 208: // LD_SET B,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 209: // LD_SET C,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 210: // LD_SET D,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 211: // LD_SET E,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 212: // LD_SET H,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 213: // LD_SET L,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 214: // SET 2,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 215: // LD_SET A,2,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,2,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 216: // LD_SET B,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 217: // LD_SET C,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 218: // LD_SET D,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 219: // LD_SET E,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 220: // LD_SET H,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 221: // LD_SET L,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 222: // SET 3,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 223: // LD_SET A,3,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,3,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 224: // LD_SET B,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 225: // LD_SET C,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 226: // LD_SET D,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 227: // LD_SET E,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 228: // LD_SET H,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 229: // LD_SET L,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 230: // SET 4,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 231: // LD_SET A,4,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,4,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 232: // LD_SET B,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 233: // LD_SET C,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 234: // LD_SET D,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 235: // LD_SET E,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 236: // LD_SET H,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 237: // LD_SET L,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 238: // SET 5,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 239: // LD_SET A,5,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,5,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 240: // LD_SET B,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 241: // LD_SET C,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 242: // LD_SET D,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 243: // LD_SET E,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 244: // LD_SET H,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 245: // LD_SET L,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 246: // SET 6,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 247: // LD_SET A,6,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,6,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	case 248: // LD_SET B,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.B=tmp1;
+		return (19);
+	break;
+	case 249: // LD_SET C,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.C=tmp1;
+		return (19);
+	break;
+	case 250: // LD_SET D,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.D=tmp1;
+		return (19);
+	break;
+	case 251: // LD_SET E,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.E=tmp1;
+		return (19);
+	break;
+	case 252: // LD_SET H,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.H=tmp1;
+		return (19);
+	break;
+	case 253: // LD_SET L,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.L=tmp1;
+		return (19);
+	break;
+	case 254: // SET 7,(IY+d)
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1))));
+		return (19);
+	break;
+	case 255: // LD_SET A,7,(IY+d)
+		tmp1=Z80free_doSetRes(processor,1,7,Z80free_Rd_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1)));
+		Z80free_Wr_Internal(processor,Z80free_addr_relativeXDCB(processor,processor->Rm.wr.IY,d1),tmp1);
+		processor->Rm.br.A=tmp1;
+		return (19);
+	break;
+	}
+
+	return -1;
+}
diff -Naru fuse-1.6.0/peripherals/disk/z80free/Z80free.h fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free.h
--- fuse-1.6.0/peripherals/disk/z80free/Z80free.h	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/disk/z80free/Z80free.h	2023-08-07 09:56:42.535039966 +0200
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2008-2009 (C) Raster Software Vigo (Sergio Costas)
+ * This file is part of Z80Free, with some bits extracted
+ * and fixed from libZ80 (from Gabriel Gambetta)
+ *
+ * Z80Free is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Z80Free is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+
+#ifndef Z80FREE_H
+#define Z80FREE_H
+
+#include <endian.h>
+#include <stdbool.h>
+#ifndef Z80_H
+typedef unsigned short int word;
+typedef unsigned char byte;
+#endif
+
+extern int Z80free_parityBit[256];
+
+#define F_S      0x80
+#define F_Z      0x40
+#define F_5      0x20
+#define F_H      0x10
+#define F_3      0x08
+#define F_PV     0x04
+#define F_N      0x02
+#define F_C      0x01
+
+//enum Z80free_prefix {Z80XX, Z80CB, Z80DD, Z80ED, Z80FD};
+
+typedef union {
+	/** Word registers. */
+	struct
+	{
+		word AF, BC, DE, HL, IX, IY, SP;
+	} wr;
+
+	/** Byte registers. SP can be accessed partially to simplify the load/save code. */
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	struct
+	{
+		byte F,A, C,B, E,D, L,H, IXl,IXh, IYl,IYh, P,S;
+	} br;
+#else
+	struct
+	{
+		byte A,F, B,C, D,E, H,L, IXh,IXl, IYh,IYl, S,P;
+	} br;
+#endif
+
+} Z80FRegs;
+
+enum Z80Status {Z80XX, Z80CB, Z80DD, Z80ED, Z80FD, Z80INT};
+
+/** A Z80 execution context. */
+typedef struct
+{
+	Z80FRegs Ra;			/* Alternate register set (R) */
+	Z80FRegs Rm;			/* Main register set (R) */
+	word	PC;				/* Program counter */
+	byte	R;				/* Refresh */
+	byte	R2;				/* Upper bit for Refresh */
+	byte	I;
+	byte	IFF1;			/* Interrupt Flipflop 1. If it's 2, decrement it and don't allow INT */
+	byte	IFF2;			/* Interrupt Flipflop 2 */
+	byte	IM;				/* Interrupt mode */
+	byte	HALT;			/* HALT status */
+	byte	INT_P;			/* INT pending */
+	byte	NMI_P;			/* NMI pending */
+	byte	empty_bus;		/* value for empty bus when procesing a maskable int */
+	word	IAddr;			/* address with offset for IX+d and IY+d */
+	byte	IAddr_done;		/* if 1, IAddr contains a valid data */
+	enum    Z80Status Status;
+	bool    M1;             /* true if the processor is in M1 state */
+	word    subtstates;     /* counts the number of tstates since the starting of the instruction */
+} Z80FREE;
+
+/* internal Z80 methods */
+
+void Z80free_setFlag(Z80FREE *processor, byte flag);
+void Z80free_resFlag(Z80FREE *processor, byte flag);
+void Z80free_valFlag(Z80FREE *processor, byte flag, int val);
+int Z80free_getFlag(Z80FREE *processor, byte flag);
+void Z80free_adjustFlags (Z80FREE *processor, byte val);
+void Z80free_adjustFlagSZP (Z80FREE *processor, byte val);
+void Z80free_adjustLogicFlag (Z80FREE *processor, int flagH);
+byte Z80free_doArithmetic (Z80FREE *processor, byte value1,byte value2, int withCarry, int isSub);
+word Z80free_doArithmetic16 (Z80FREE *processor, word value1,word value2, int withCarry, int isSub);
+void Z80free_doAND (Z80FREE *processor, byte value);
+void Z80free_doOR (Z80FREE *processor, byte value);
+void Z80free_doXOR (Z80FREE *processor, byte value);
+void Z80free_doBIT (Z80FREE *processor, int b, byte val);
+byte Z80free_doSetRes (Z80FREE *processor, int bit, int pos, byte val);
+byte Z80free_doIncDec (Z80FREE *processor, byte val, int isDec);
+word Z80free_doIncDec16 (Z80FREE *processor, word val, int isDec);
+byte Z80free_doRLC (Z80FREE *processor, int adjFlags, byte val);
+byte Z80free_doRL (Z80FREE *processor, int adjFlags, byte val);
+byte Z80free_doRRC (Z80FREE *processor, int adjFlags, byte val);
+byte Z80free_doRR (Z80FREE *processor, int adjFlags, byte val);
+byte Z80free_doSL (Z80FREE *processor, int isArith, byte val);
+byte Z80free_doSR (Z80FREE *processor, int isArith, byte val);
+void Z80free_doPush (Z80FREE *processor, word val);
+word Z80free_doPop (Z80FREE *processor);
+void Z80free_doDAA (Z80FREE *processor);
+byte Z80free_readR(Z80FREE *processor);
+void Z80free_setR(Z80FREE *processor,byte value);
+byte Z80free_readI(Z80FREE *processor);
+void Z80free_doRRD(Z80FREE *processor);
+void Z80free_doRLD(Z80FREE *processor);
+
+void Z80free_jump_relative(Z80FREE *processor,byte relvar);
+word Z80free_addr_relative(Z80FREE *processor,word address);
+word Z80free_addr_relativeXDCB(Z80FREE *processor,word address,byte d1);
+byte Z80free_read_param_8(Z80FREE *z80);
+word Z80free_read_param_16(Z80FREE *z80);
+word Z80free_read16 (Z80FREE *processor, word addr);
+void Z80free_write16 (Z80FREE *processor, word addr,word val);
+
+/* external Z80 methods */
+
+void Z80free_reset(Z80FREE *);
+int Z80free_step(Z80FREE *);
+int Z80free_ustep(Z80FREE *);
+void Z80free_INT(Z80FREE *,byte);
+
+void Z80free_INTserved(Z80FREE *);
+
+byte Z80free_Rd_Internal (Z80FREE *processor,word Addr);
+void Z80free_Wr_Internal (Z80FREE *processor,word Addr, byte Value);
+byte Z80free_In_Internal (Z80FREE *processor,word Port);
+void Z80free_Out_Internal (Z80FREE *processor,word Port, byte Value);
+
+byte Z80free_Rd (word Addr);
+void Z80free_Wr (word Addr, byte Value);
+byte Z80free_In (word Port);
+void Z80free_Out (word Port, byte Value);
+
+/* Opcode functions */
+
+int Z80free_codes (Z80FREE *processor,byte opcode);
+int Z80free_codesCB (Z80FREE *processor,byte opcode);
+int Z80free_codesDD (Z80FREE *processor,byte opcode);
+int Z80free_codesED (Z80FREE *processor,byte opcode);
+int Z80free_codesFD (Z80FREE *processor,byte opcode);
+int Z80free_codesDDCB (Z80FREE *processor,byte d1);
+int Z80free_codesFDCB (Z80FREE *processor,byte d1);
+
+#endif
diff -Naru fuse-1.6.0/peripherals/Makefile.am fuse-1.6.0-fdd3000-0.2.1/peripherals/Makefile.am
--- fuse-1.6.0/peripherals/Makefile.am	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/peripherals/Makefile.am	2023-08-07 09:56:42.535039966 +0200
@@ -45,11 +45,21 @@
                 peripherals/disk/disciple.c \
                 peripherals/disk/disk.c \
                 peripherals/disk/fdd.c \
+                peripherals/disk/fdd3000.c \
+                peripherals/disk/ti397.c \
                 peripherals/disk/opus.c \
                 peripherals/disk/plusd.c \
                 peripherals/disk/trdos.c \
                 peripherals/disk/upd_fdc.c \
                 peripherals/disk/wd_fdc.c \
+                peripherals/disk/z80free/Z80free.c \
+                peripherals/disk/z80free/Z80free_codes.c \
+                peripherals/disk/z80free/Z80free_codesCB.c \
+                peripherals/disk/z80free/Z80free_codesDD.c \
+                peripherals/disk/z80free/Z80free_codesDDCB.c \
+                peripherals/disk/z80free/Z80free_codesED.c \
+                peripherals/disk/z80free/Z80free_codesFD.c \
+                peripherals/disk/z80free/Z80free_codesFDCB.c \
                 peripherals/ide/divide.c \
                 peripherals/ide/divmmc.c \
                 peripherals/ide/divxxx.c \
@@ -95,11 +105,15 @@
                   peripherals/disk/disciple.h \
                   peripherals/disk/disk.h \
                   peripherals/disk/fdd.h \
+                  peripherals/disk/fdd3000.h \
+                  peripherals/disk/ti397.h \
+                  peripherals/disk/fdd3boot.h \
                   peripherals/disk/opus.h \
                   peripherals/disk/plusd.h \
                   peripherals/disk/trdos.h \
                   peripherals/disk/upd_fdc.h \
                   peripherals/disk/wd_fdc.h \
+                  peripherals/disk/z80free/Z80free.h \
                   peripherals/ide/divide.h \
                   peripherals/ide/divmmc.h \
                   peripherals/ide/divxxx.h \
diff -Naru fuse-1.6.0/periph.h fuse-1.6.0-fdd3000-0.2.1/periph.h
--- fuse-1.6.0/periph.h	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/periph.h	2023-08-07 09:56:42.535039966 +0200
@@ -47,6 +47,7 @@
   PERIPH_TYPE_PLUSD,          /* +D disk interface */
   PERIPH_TYPE_DIDAKTIK80,     /* Didaktik 40/80 disk interface */
   PERIPH_TYPE_DISCIPLE,       /* DISCiPLE disk interface */
+  PERIPH_TYPE_FDD3000,
   PERIPH_TYPE_FULLER,         /* Fuller box */
   PERIPH_TYPE_INTERFACE1,     /* Interface 1 */
   PERIPH_TYPE_INTERFACE2,     /* Interface 2 */
diff -Naru fuse-1.6.0/roms/fdd3stavi.rom fuse-1.6.0-fdd3000-0.2.1/roms/fdd3stavi.rom
--- fuse-1.6.0/roms/fdd3stavi.rom	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/roms/fdd3stavi.rom	2023-08-07 09:56:42.535039966 +0200
@@ -0,0 +1,24 @@
+| 'n:\a> !:!V-fOnUFˆ*]\"?!~* !+~8"]\k~G~(#~ ###~ *;!! *?!S]\#   ~(_0! ^#V*]\#>#^#V  IOym	rj#(cA24!# *]\~$("(+"]\  ~e([8 !  9##^#VG((26! r+s  !:!~e(#jcKCK!::!2:!::!˟#j*]\~e(j  #jcKCK!!  "K!~e >24!~e>24! ~N(((j24!>24!  ~D:4!29! ޯ24!~ej24!   ~;j  !:!$˖ˆ!-Rbv!:!!:!ˮˆ!Rb:
+9
+	 IOAR 
+
+#  
+H#       #  S
+
+D
+4N
+
+ i	 
+/	PUVI ^"?!SA!^#V#!:!! *?![A!#"?!~(G3*]\~ej*?!c!C!S!"!"!"	!"!>2/!>20!! !͕8l20!>2/!!  ͕8l(8j:/!(*!K![!*!*	!7>>2\ S  Q 1 | 8!x!~# >>>2!?(KR!!  Supersede (Y/N) ?  Wrong data type { >{=\w *]\"_\!6 !:!Nˎ!v>
+22!!/! .:0!G.yD*!1!́:1! :2!=22! >>
+22!!/! ̓:/!((! !!  :0!G̓!1!́y(:2!=22!(>*>>*~WOz_zWP @(#{ P(zz (> #>@P _(>P W({_zwO#ǯSTART ,!& >y:8< >8y ÕdìÕÔÿTa
+È:6!*I!c#N#F!:!(˦ˆORb~+!  !@ B8x(6 #<Gͬ0: !((	 $>G z  ( >2 !:\d!  ͈*=!~(1 :!G:\ x ʀ1 1 !!1 1 j2\À:4!(h͕>2 !d>>2 !:4!2.!dͬ0*=!/ : ("*K!| 0CK!y͕ :4!G[K!>: !   6 #+x x( !  7E~0a8 G#~$j+x26!"I!~(###~=jy`@j͂IG!/:  ):4![K! ͔):6!w#q#p#  x  yO0*Y\+U>
+%:9!~h͕>>	%>2 !:4!d:4!>%h͕> %*]\~#(ej>2 !G!I|  *]\~e >#lc(A2!>h͕>Uh͕>2 !d:4!0>U>:6! I O R Ajz26!+m͕::!_(*K!:6!W> U! "\!P"\!!"\>2 !+! ph<6 ͕:!d># *]\~23!(((7(<Zj  #(>I  #(*]\~,   #(>)  >   E8y`(@ "E!*]\##"]\>23!*]\!:3!G
+=
+(
+"
+!  h*S\*Y\7RDM> ?KKKh!  >$! ! @h*E!v>(>#N#F+!  SG!CE!>2 !d~ O:!2.!͕>2 !>N(I!(E (A# -:4! /!!>2!! Y(N  2!6 ?F ? 2    " *K\R" C >
+C S >2-!͕:.!G Q:-!_>2 !N T F(!> >2 !:.!d~*E! B0*E!|(9MD!  "E!  *G!"G!y͕ :.!G >2 !d 	~8 7# *]\~23!e((4(9j  e(#(*]\~,(>S>O  #(>A  >8  E"N!> 8>29!y26!`(@(>>24!*]\##"]\>23!!:3!(X(F(2( (> KCP!  CN!>2M!hQ!"N!!  "P!KCN!KCP!! "N!! @"P!:4!2M!h>28!!T:!*?!!M!>2 !N:!2.!x͕B ͔~ݾ   (	8
+>KÄ  {2-!͔ t~  (
+(>8>Kc  Tnf"E!F*N!:9!2*  "E!MD:6!w#%^V*  "E!{(R8SE!nf} * "G!ͿF 2!!:.!G>2 !d ͬ0: ! :!K!!  7*E! R0*E!}($!  "E!͔8(H x([G!SG!ʯ:8! ][S\*Y\+NF*e\	P 87r03d*e\#NF	"K\nf"B\|>  =2D\*S\"G!>NF0 6"G!"?!28!l :/! : ! :!7:9!(:4!2!>C	h͕>%:6!P( U(V(h͕>2 !d!#6 +| !"=!! ";!>>?G!6 + !>Uw/<(&!W\!M >2/!>20!! !6͕((Cͬ:! 8!]zg1w##zƱw!\>0!   2M!:!(!n!6 Î]!  6ɯ2;]]!.!   \
+!k 91 STAVI 128K  TOS  .  !
\ Brak znaku nowej linii na końcu pliku
diff -Naru fuse-1.6.0/roms/fdd3timex.rom fuse-1.6.0-fdd3000-0.2.1/roms/fdd3timex.rom
--- fuse-1.6.0/roms/fdd3timex.rom	1970-01-01 01:00:00.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/roms/fdd3timex.rom	2023-08-29 08:45:12.122588797 +0200
@@ -0,0 +1,20 @@
+}/װn:\a> | !:!V*fLnNFˆ*]\"?!+~0("]\d~G~(#~ ###~ *;!! *?!S]\ (* #   ~(_0! ^#V*]\~#&#^#V )XR	g>"(~>24!" *]\~$("(+"]\  ^([8 !  9##^#VG((26! r+s  ^(">~FCK!::!2:!::!˟">*]\~^(>  ">~FCK!!  "K!^ >24!^>24!~N(((>24!>24!  ~D:4!29! 24!~^>24!  ;>  !:!T(˖ˆ!*R8v!:!!:!#ˮˆ!R8:
+	 IOAR 
+
+
+#  D#      q#  Hv
+9
+)C
+m
+ N	 
+	PUVI S"?!SA!^#V#!:!! *?![A!#"?!~(G3*]\~^>*?!~!JC!S!"!"!"	!"!>2/!>20!! !T	 8@20!>2/!!  T	 8@͕(	 8>:/!(*!K![!*!*	!7>0>2\ S  Q - | 8!x!~# 2!(K(!!  Supersede (Y/N) ?  Wrong data type { >{=\w *]\"_\!T>
+22!!/! :0!GyD!1!@:1! :2!=22! >>
+22!!/! B:/!((! !!  :0!GB!1!@y(:2!=22!(>>>~WOz_zWP @(#{ P(zz (> Ð#>@P _(>P W({_zwO#ǯ> !  w >?G! ";!!"=!ð! *"START"~MÕTÕê+<
+ì~:6!*I!~#N#FP!:!p,˦ˆLR8ׯ/!  !@ B8x(6 #<G͕0: !((	  >G װz  ( >2 !:\M!  *=!~>0~(- :!G:\ x (- - !!- - >2\6 !:4!>(`~>2 !M>2 !:4!2.!M͕0!+ : ("*K!| {0CK!y~ :4!G[K!>: {!   6 #ׯ/x x( !  7D~0a8 G#~$>+x26!"I!~(###~=>y`@>͋/!+:  &[K! ):6!w#q#p#  x  :U!=OyO0*Y\+׻>
+%:9!K`~>>	%>2 !:4!M:4!>%`~> %#(^>>2 !/!e  ^ >"@~(>2!>`~>J`~>2 !M:4!0>J>:6! I O R A>z26!ׯ/c~::!_(*K!:6!W> J! "\!P"\!!"\>2 !ׯ/! f`<6 ~:!M>" *]\~23!(((1(4P>  "(>A  "(*]\~,   "(>%  >  D8y`(@ "E!*]\##"]\>23!*]\!:3!"
+
+
+	!  `*S\*Y\7RDM> ?FFF`!  >$! ! @`*E!v>(>#N#F+!  SG!CE!>2 !MK M:!2.!~>2 !>%(E!(A (=# +:4! +!!>2! Y(N  2!   2    " *K\R" C >
+C S >2-!~:.!G Q:-!_>2 !% + (> >2 !:.!MK*E! B0*E!|(9MD!  "E!  *G!"G!y~ :.!G >2 !M 	K8 7" *]\~23!^((0(3>  ^("(*]\~,(>M>I  "(>=  >6  D"N!> 8>29!y26!`(@(>>24!*]\##"]\>23!!:3!(X(F(2( (> FCP!  CN!>2M!`m!"N!!  "P!FCN!FCP!! "N!! @"P!:4!2M!`6>28!!#:!0h! [K!0h!!!  e!M!>2 !%|:!2.!x~| o~ݾ   (	8
+>Ko  {2-! t~  (
+(>8>Kc  Tnf"E!F*N!:9!2*  "E!MD:6!w#%^V*  "E!{(R8SE!nf} * "G!ͪ 2!:.!G>2 !M ͕0: ! :!K!!  7*E! R0*E!}($!  "E!8(H x([G!SG!ʯ:8! C[S\*Y\+NFM׻#NF	"K\nf"B\|>  =2D\*S\"G!>NF0 "G!"K!28!͕(	 @:/! : ! :!7:9!(:4!2!>*	`~>%:6!P( U(V(`~>2 !M1 b>2/!>20!! !6T(	! ͕ "  !_h_ >2:!!h[  e! >2:!!h!!e6#6>2 !!   >~M͕! *Y\	 #!	 U/1 b!> !hzg1w##zƱw!Uh !h !   hh?!  1985 TMX Portugal - TOS V  . ìh
\ Brak znaku nowej linii na końcu pliku
diff -Naru fuse-1.6.0/roms/Makefile.am fuse-1.6.0-fdd3000-0.2.1/roms/Makefile.am
--- fuse-1.6.0/roms/Makefile.am	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/roms/Makefile.am	2023-08-29 12:44:23.311296060 +0200
@@ -41,7 +41,9 @@
        roms/tc2068-1.rom \
        roms/se-0.rom \
        roms/se-1.rom \
-       roms/speccyboot-1.4.rom
+       roms/speccyboot-1.4.rom \
+       roms/fdd3stavi.rom \
+       roms/fdd3timex.rom
 
 pkgdata_DATA += $(ROMS)
 
diff -Naru fuse-1.6.0/settings.c fuse-1.6.0-fdd3000-0.2.1/settings.c
diff -Naru fuse-1.6.0/settings.dat fuse-1.6.0-fdd3000-0.2.1/settings.dat
--- fuse-1.6.0/settings.dat	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/settings.dat	2023-08-07 09:56:42.538373310 +0200
@@ -67,6 +67,7 @@
 multiface1_stealth, boolean, 0
 snapsasz80, null, 0
 opus, boolean, 0
+fdd3000, boolean, 0
 pal_tv2x, boolean, 0
 movie_compr, string, NULL
 movie_start, string, NULL
@@ -157,6 +158,7 @@
 start_machine, string, "48", 'm', machine
 record_file, string, NULL, 'r', record, recordfile
 opusdisk_file, string, NULL,, opusdisk
+fdd3000disk_file, string, NULL,, fdd3000disk
 playback_file, string, NULL, 'p', playback, playbackfile
 plus3disk_file, string, NULL,, plus3disk
 plusddisk_file, string, NULL,, plusddisk
@@ -258,6 +260,7 @@
 rom_multiface128, string, "mf128.rom",
 rom_multiface3, string, "mf3.rom",
 rom_opus, string, "opus.rom",
+rom_fdd3000, string, "fdd3stavi.rom",
 rom_speccyboot, string, "speccyboot-1.4.rom",
 rom_ttx2000s, string, "ttx2000s.rom",
 rom_usource, string, "usource.rom",
@@ -277,6 +280,10 @@
 drive_disciple2_type, string, NULL
 drive_opus1_type, string, NULL
 drive_opus2_type, string, NULL
+drive_fdd3000a_type, string, NULL
+drive_fdd3000b_type, string, NULL
+drive_fdd3000c_type, string, NULL
+drive_fdd3000d_type, string, NULL
 drive_40_max_track, numeric, 42
 drive_80_max_track, numeric, 84
 
diff -Naru fuse-1.6.0/settings.h fuse-1.6.0-fdd3000-0.2.1/settings.h
diff -Naru fuse-1.6.0/settings.pl fuse-1.6.0-fdd3000-0.2.1/settings.pl
--- fuse-1.6.0/settings.pl	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/settings.pl	2023-08-07 09:56:42.538373310 +0200
@@ -771,6 +771,7 @@
     case  9: return &( settings->rom_speccyboot );
     case 10: return &( settings->rom_ttx2000s );
     case 11: return &( settings->rom_usource );
+    case 12: return &( settings->rom_fdd3000 );
     default: return NULL;
     }
   }
diff -Naru fuse-1.6.0/ui/fb/keysyms.c fuse-1.6.0-fdd3000-0.2.1/ui/fb/keysyms.c
diff -Naru fuse-1.6.0/ui/gtk/keysyms.c fuse-1.6.0-fdd3000-0.2.1/ui/gtk/keysyms.c
diff -Naru fuse-1.6.0/ui/gtk/menu_data.c fuse-1.6.0-fdd3000-0.2.1/ui/gtk/menu_data.c
diff -Naru fuse-1.6.0/ui/gtk/options.c fuse-1.6.0-fdd3000-0.2.1/ui/gtk/options.c
diff -Naru fuse-1.6.0/ui/null/options.c fuse-1.6.0-fdd3000-0.2.1/ui/null/options.c
diff -Naru fuse-1.6.0/ui/options.dat fuse-1.6.0-fdd3000-0.2.1/ui/options.dat
--- fuse-1.6.0/ui/options.dat	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/ui/options.dat	2023-08-07 09:56:42.538373310 +0200
@@ -80,6 +80,7 @@
 Checkbox, +(D) interface, plusd, INPUT_KEY_d
 Checkbox, Dida(k)tik 80 interface, didaktik80, INPUT_KEY_k
 Checkbox, DISCi(P)LE interf(a)ce, disciple, INPUT_KEY_p
+Checkbox, FDD(3)000 interface, fdd3000, INPUT_KEY_3
 Checkbox, (B)eta 128 interface, beta128, INPUT_KEY_b
 Checkbox, Beta 128 (a)uto-boot in 48K machines, beta128_48boot, INPUT_KEY_a
 Checkbox, (O)pus Discovery interface, opus, INPUT_KEY_o
@@ -122,6 +123,10 @@
 Combo, Dida(k)tik 80 Drive B, drive_didaktik80b_type, INPUT_KEY_k, Disabled|Single-sided 40 track|Double-sided 40 track|Single-sided 80 track|*Double-sided 80 track
 Combo, DI(S)CiPLE Drive 1, drive_disciple1_type, INPUT_KEY_s, Single-sided 40 track|Double-sided 40 track|Single-sided 80 track|*Double-sided 80 track
 Combo, DISCiP(L)E Drive 2, drive_disciple2_type, INPUT_KEY_l, Disabled|Single-sided 40 track|Double-sided 40 track|Single-sided 80 track|*Double-sided 80 track
+Combo, FDD3000 Drive (A), drive_fdd3000a_type, INPUT_KEY_q, *Single-sided 40 track|Double-sided 40 track|Double-sided 80 track
+Combo, FDD3000 Drive (B), drive_fdd3000b_type, INPUT_KEY_w, Disabled|*Single-sided 40 track|Double-sided 40 track|Double-sided 80 track
+Combo, FDD3000 Drive (C), drive_fdd3000c_type, INPUT_KEY_e, Disabled|*Single-sided 40 track|Double-sided 40 track|Double-sided 80 track
+Combo, FDD3000 Drive (D), drive_fdd3000d_type, INPUT_KEY_r, Disabled|*Single-sided 40 track|Double-sided 40 track|Double-sided 80 track
 Combo, (O)pus Drive 1, drive_opus1_type, INPUT_KEY_o, *Single-sided 40 track|Double-sided 40 track|Single-sided 80 track|Double-sided 80 track
 Combo, O(p)us Drive 2, drive_opus2_type, INPUT_KEY_p, Disabled|*Single-sided 40 track|Double-sided 40 track|Single-sided 80 track|Double-sided 80 track
 Combo, (T)ry merge 'B' side of disks, disk_try_merge, INPUT_KEY_t, Never|*With single-sided drives|Always
diff -Naru fuse-1.6.0/ui/sdl/keysyms.c fuse-1.6.0-fdd3000-0.2.1/ui/sdl/keysyms.c
diff -Naru fuse-1.6.0/ui/svga/keysyms.c fuse-1.6.0-fdd3000-0.2.1/ui/svga/keysyms.c
diff -Naru fuse-1.6.0/ui/ui.h fuse-1.6.0-fdd3000-0.2.1/ui/ui.h
--- fuse-1.6.0/ui/ui.h	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/ui/ui.h	2023-08-07 09:56:42.538373310 +0200
@@ -135,6 +135,7 @@
   UI_MENU_ITEM_MACHINE_PROFILER,
   UI_MENU_ITEM_MACHINE_MULTIFACE,
   UI_MENU_ITEM_MACHINE_DIDAKTIK80_SNAP,
+  UI_MENU_ITEM_MACHINE_FDD3000_RESET,
   UI_MENU_ITEM_MEDIA_CARTRIDGE,
   UI_MENU_ITEM_MEDIA_CARTRIDGE_DOCK,
   UI_MENU_ITEM_MEDIA_CARTRIDGE_DOCK_EJECT,
@@ -186,6 +187,19 @@
   UI_MENU_ITEM_MEDIA_DISK_BETA_D_EJECT,
   UI_MENU_ITEM_MEDIA_DISK_BETA_D_FLIP_SET,
   UI_MENU_ITEM_MEDIA_DISK_BETA_D_WP_SET,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_A,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_A_EJECT,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_A_FLIP_SET,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_B,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_B_EJECT,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_B_FLIP_SET,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_C,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_C_EJECT,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_C_FLIP_SET,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_D,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_D_EJECT,
+  UI_MENU_ITEM_MEDIA_DISK_FDD3000_D_FLIP_SET,
   UI_MENU_ITEM_MEDIA_DISK_PLUSD,
   UI_MENU_ITEM_MEDIA_DISK_PLUSD_1,
   UI_MENU_ITEM_MEDIA_DISK_PLUSD_1_EJECT,
diff -Naru fuse-1.6.0/ui/uimedia.h fuse-1.6.0-fdd3000-0.2.1/ui/uimedia.h
--- fuse-1.6.0/ui/uimedia.h	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/ui/uimedia.h	2023-08-07 09:56:42.541706655 +0200
@@ -85,6 +85,7 @@
   UI_MEDIA_CONTROLLER_OPUS,
   UI_MEDIA_CONTROLLER_DISCIPLE,
   UI_MEDIA_CONTROLLER_DIDAKTIK,
+  UI_MEDIA_CONTROLLER_FDD3000,
 } ui_media_controller;
 
 #endif			/* #ifndef FUSE_UIMEDIA_H */
diff -Naru fuse-1.6.0/ui/widget/menu_data.c fuse-1.6.0-fdd3000-0.2.1/ui/widget/menu_data.c
diff -Naru fuse-1.6.0/ui/widget/options.c fuse-1.6.0-fdd3000-0.2.1/ui/widget/options.c
diff -Naru fuse-1.6.0/ui/wii/keysyms.c fuse-1.6.0-fdd3000-0.2.1/ui/wii/keysyms.c
diff -Naru fuse-1.6.0/ui/win32/keysyms.c fuse-1.6.0-fdd3000-0.2.1/ui/win32/keysyms.c
diff -Naru fuse-1.6.0/ui/win32/menu_data.c fuse-1.6.0-fdd3000-0.2.1/ui/win32/menu_data.c
diff -Naru fuse-1.6.0/ui/win32/menu_data.rc fuse-1.6.0-fdd3000-0.2.1/ui/win32/menu_data.rc
diff -Naru fuse-1.6.0/ui/win32/options.c fuse-1.6.0-fdd3000-0.2.1/ui/win32/options.c
diff -Naru fuse-1.6.0/ui/win32/options.rc fuse-1.6.0-fdd3000-0.2.1/ui/win32/options.rc
diff -Naru fuse-1.6.0/ui/xlib/keysyms.c fuse-1.6.0-fdd3000-0.2.1/ui/xlib/keysyms.c
diff -Naru fuse-1.6.0/ui/xlib/xpixmaps.c fuse-1.6.0-fdd3000-0.2.1/ui/xlib/xpixmaps.c
diff -Naru fuse-1.6.0/ui.c fuse-1.6.0-fdd3000-0.2.1/ui.c
--- fuse-1.6.0/ui.c	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/ui.c	2023-08-07 09:56:42.541706655 +0200
@@ -242,6 +242,8 @@
 
   { UI_MENU_ITEM_MACHINE_DIDAKTIK80_SNAP, "/Machine/Didaktik SNAP" },
 
+  { UI_MENU_ITEM_MACHINE_FDD3000_RESET, "/Machine/FDD3000 reset" },
+
   { UI_MENU_ITEM_MEDIA_CARTRIDGE, "/Media/Cartridge" },
 
   { UI_MENU_ITEM_MEDIA_CARTRIDGE_DOCK, "/Media/Cartridge/Timex Dock" },
@@ -451,6 +453,57 @@
     "/Media/Disk/Beta/Drive D:/Write protect/Enable",
     "/Media/Disk/Beta/Drive D:/Write protect/Disable", 1 },
 
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000, "/Media/Disk/FDD3000" },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_A, "/Media/Disk/FDD3000/Drive A" },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_A_EJECT,
+    "/Media/Disk/FDD3000/Drive A/Eject",
+    "/Media/Disk/FDD3000/Drive A/Save As...", 0,
+    "/Media/Disk/FDD3000/Drive A/Save", 0,
+    "/Media/Disk/FDD3000/Drive A/Flip disk", 0 },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_A_FLIP_SET,
+    "/Media/Disk/FDD3000/Drive A/Flip disk/Turn upside down",
+    "/Media/Disk/FDD3000/Drive A/Flip disk/Turn back", 1 },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_B, "/Media/Disk/FDD3000/Drive B" },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_B_EJECT,
+    "/Media/Disk/FDD3000/Drive B/Eject",
+    "/Media/Disk/FDD3000/Drive B/Save As...", 0,
+    "/Media/Disk/FDD3000/Drive B/Save", 0,
+    "/Media/Disk/FDD3000/Drive B/Flip disk", 0 },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_B_FLIP_SET,
+    "/Media/Disk/FDD3000/Drive B/Flip disk/Turn upside down",
+    "/Media/Disk/FDD3000/Drive B/Flip disk/Turn back", 1 },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_C, "/Media/Disk/FDD3000/Drive C" },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_C_EJECT,
+    "/Media/Disk/FDD3000/Drive C/Eject",
+    "/Media/Disk/FDD3000/Drive C/Save As...", 0,
+    "/Media/Disk/FDD3000/Drive C/Save", 0,
+    "/Media/Disk/FDD3000/Drive C/Flip disk", 0 },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_C_FLIP_SET,
+    "/Media/Disk/FDD3000/Drive C/Flip disk/Turn upside down",
+    "/Media/Disk/FDD3000/Drive C/Flip disk/Turn back", 1 },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_D, "/Media/Disk/FDD3000/Drive D" },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_D_EJECT,
+    "/Media/Disk/FDD3000/Drive D/Eject",
+    "/Media/Disk/FDD3000/Drive D/Save As...", 0,
+    "/Media/Disk/FDD3000/Drive D/Save", 0,
+    "/Media/Disk/FDD3000/Drive D/Flip disk", 0 },
+
+  { UI_MENU_ITEM_MEDIA_DISK_FDD3000_D_FLIP_SET,
+    "/Media/Disk/FDD3000/Drive D/Flip disk/Turn upside down",
+    "/Media/Disk/FDD3000/Drive D/Flip disk/Turn back", 1 },
+
   { UI_MENU_ITEM_MEDIA_DISK_PLUSD, "/Media/Disk/+D" },
 
   { UI_MENU_ITEM_MEDIA_DISK_PLUSD_1, "/Media/Disk/+D/Drive 1" },
diff -Naru fuse-1.6.0/ylwrap fuse-1.6.0-fdd3000-0.2.1/ylwrap
diff -Naru fuse-1.6.0/z80/coretest.c fuse-1.6.0-fdd3000-0.2.1/z80/coretest.c
--- fuse-1.6.0/z80/coretest.c	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/z80/coretest.c	2023-08-07 09:56:42.541706655 +0200
@@ -33,6 +33,7 @@
 #include "peripherals/disk/didaktik.h"
 #include "peripherals/disk/disciple.h"
 #include "peripherals/disk/opus.h"
+#include "peripherals/disk/ti397.h"
 #include "peripherals/disk/plusd.h"
 #include "peripherals/ide/divide.h"
 #include "peripherals/ide/divmmc.h"
@@ -484,6 +485,23 @@
   abort();
 }
 
+
+int fdd3000_available = 0;
+int fdd3000_active = 0;
+
+void
+fdd3000_page( void )
+{
+  abort();
+}
+
+void
+fdd3000_unpage( void )
+{
+  abort();
+}
+
+
 int plusd_available = 0;
 int plusd_active = 0;
 
diff -Naru fuse-1.6.0/z80/.deps/z80_coretest-coretest.Po fuse-1.6.0-fdd3000-0.2.1/z80/.deps/z80_coretest-coretest.Po
diff -Naru fuse-1.6.0/z80/.deps/z80_coretest-z80.Po fuse-1.6.0-fdd3000-0.2.1/z80/.deps/z80_coretest-z80.Po
diff -Naru fuse-1.6.0/z80/Makefile.am fuse-1.6.0-fdd3000-0.2.1/z80/Makefile.am
--- fuse-1.6.0/z80/Makefile.am	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/z80/Makefile.am	2023-08-07 09:56:42.541706655 +0200
@@ -76,7 +76,7 @@
 
 ## The core tester
 
-noinst_PROGRAMS += z80/coretest
+#noinst_PROGRAMS += z80/coretest
 
 z80_coretest_SOURCES = z80/coretest.c z80/z80.c
 z80_coretest_LDADD = z80/z80_coretest.o $(GLIB_LIBS) $(LIBSPECTRUM_LIBS)
diff -Naru fuse-1.6.0/z80/opcodes_base.c fuse-1.6.0-fdd3000-0.2.1/z80/opcodes_base.c
diff -Naru fuse-1.6.0/z80/z80_cb.c fuse-1.6.0-fdd3000-0.2.1/z80/z80_cb.c
diff -Naru fuse-1.6.0/z80/z80_checks.h fuse-1.6.0-fdd3000-0.2.1/z80/z80_checks.h
--- fuse-1.6.0/z80/z80_checks.h	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/z80/z80_checks.h	2023-08-29 12:21:19.010999613 +0200
@@ -8,6 +8,7 @@
 SETUP_CHECK( usource, usource_available )
 SETUP_CHECK( multiface, multiface_activated )
 SETUP_CHECK( if1p, if1_available )
+SETUP_CHECK( fdd3000_early, fdd3000_available )
 SETUP_CHECK( divide_early, settings_current.divide_enabled )
 SETUP_CHECK( divmmc_early, settings_current.divmmc_enabled )
 SETUP_CHECK( spectranet_page, spectranet_available && !settings_current.spectranet_disable )
@@ -17,6 +18,7 @@
 SETUP_CHECK( if1u, if1_available )
 SETUP_CHECK( divide_late, settings_current.divide_enabled )
 SETUP_CHECK( divmmc_late, settings_current.divmmc_enabled )
+SETUP_CHECK( fdd3000_late, fdd3000_available )
 SETUP_CHECK( opus, opus_available )
 SETUP_CHECK( spectranet_unpage, spectranet_available )
 SETUP_CHECK( z80_iff2_read, z80.iff2_read )
diff -Naru fuse-1.6.0/z80/z80_ddfd.c fuse-1.6.0-fdd3000-0.2.1/z80/z80_ddfd.c
diff -Naru fuse-1.6.0/z80/z80_ddfdcb.c fuse-1.6.0-fdd3000-0.2.1/z80/z80_ddfdcb.c
diff -Naru fuse-1.6.0/z80/z80_ed.c fuse-1.6.0-fdd3000-0.2.1/z80/z80_ed.c
diff -Naru fuse-1.6.0/z80/z80_ops.c fuse-1.6.0-fdd3000-0.2.1/z80/z80_ops.c
--- fuse-1.6.0/z80/z80_ops.c	2021-02-27 04:02:48.000000000 +0100
+++ fuse-1.6.0-fdd3000-0.2.1/z80/z80_ops.c	2023-08-29 12:14:30.410948892 +0200
@@ -36,6 +36,8 @@
 #include "peripherals/disk/beta.h"
 #include "peripherals/disk/didaktik.h"
 #include "peripherals/disk/disciple.h"
+#include "peripherals/disk/ti397.h"
+#include "peripherals/disk/fdd3000.h"
 #include "peripherals/disk/opus.h"
 #include "peripherals/disk/plusd.h"
 #include "peripherals/ide/divide.h"
@@ -190,7 +192,19 @@
     }
 
     END_CHECK
+/*
+    CHECK( fdd3000, fdd3000_available )
+    
+    if( fdd3000_active ) {
+      if( PC == 0x0604 ) {
+        fdd3000_unpage();
+      }
+    } else if( PC == 0x0000 || PC == 0x0008 ) {
+      fdd3000_page();
+    }
 
+    END_CHECK    
+*/
     CHECK( didaktik80, didaktik80_available )
 
     if( PC == 0x0000 || PC == 0x0008 ) {
@@ -233,6 +247,13 @@
 
     END_CHECK
 
+    CHECK( fdd3000_early, fdd3000_available )
+    
+    if( (!fdd3000_active ) && ( PC == 0x0000 || PC == 0x0008 ) ) { fdd3000_page(); }
+
+    END_CHECK    
+
+
     CHECK( divide_early, settings_current.divide_enabled )
     
     if( ( PC & 0xff00 ) == 0x3d00 ) {
@@ -260,6 +281,7 @@
 
     END_CHECK
 
+
   opcode_delay:
 
     contend_read( PC, 4 );
@@ -310,6 +332,13 @@
     
     END_CHECK
 
+    CHECK( fdd3000_late, fdd3000_available )
+    
+    if ( ( fdd3000_active ) && ( PC == 0x0604 ) ) { fdd3000_unpage();  }
+
+    END_CHECK    
+
+
     CHECK( opus, opus_available )
 
     if( opus_active ) {
@@ -352,6 +381,7 @@
 
     END_CHECK
 
+
   end_opcode:
     PC++; R++;
     last_Q = Q; /* keep Q value from previous opcode for SCF and CCF */
@@ -361,6 +391,7 @@
 #include "z80/opcodes_base.c"
     }
 
+    if (fdd3000_available) { fddCpuStep(); }
   }
 
 }
